Productos como referentes expl√≠citos en el modelado de procesos de negocios
ÔªøLa necesidad de eficiencia y organizaci√≥n en un mundo cada
vez m√°s competitivo, ha impulsado, en la √∫ltima d√©cada, la investigaci√≥n
y desarrollo de distintos m√©todos y formal√≠smos (lenguajes) en el area
de procesos de negocios; particularmente ha tenido un gran auge la especificaci√≥n y verificaci√≥n de modelos de procesos de negocios. Entre los
lenguajes m√°s difundidos podemos mencionar Business Process Modeling
Notation(BPMN), para el cual se han aportado numerosos trabajos para
el an√°lisis formal de sus modelos. Sin embargo, como sucede en la gran
mayoria de este tipo de lenguajes de modelado, no proveen como parte
del lenguaje un objeto que permita especificar productos (una referencia
a un objeto emp√≠rico con propiedades) como un referente expl√≠cito del
modelo.
En este trabajo analizamos diferentes trabajos en el √°rea de m√©todos
formales que tienen como objetivo brindar soporte formal a diferentes
lenguajes para el modelado de procesos de negocios. Retomamos un formalismo para especificar procesos de negocios, que provee la especificaci√≥n de productos como referentes expl√≠citos del modelo y extendemos
algunas de sus caracter√≠sticas con el fin de ampliar su campo de aplicaci√≥n. Tambi√©n proponemos una sintaxis de alto nivel para el mismo,
que facilita la especifiaci√≥n de sus modelos.
Palabras Clave: M√©todos Formales, Real-Time, Aut√≥matas Temporizados,
Procesos de Negocios
1 Introducci√≥n
El constante esfuerzo de distintas organizaciones por el perfeccionamiento de sus
procesos en busca de eficiencia y control, ha impulsado el actual auge de diversos
m√©todos y lenguajes para el modelado de procesos de negocios. Si bien existen diversos lenguajes como Business Process Modeling Language(BPMN) entre otros,
en su gran mayor√≠a est√°n orientados a servicios y en general no proveen una
sem√°ntica formal que permita realizar an√°lisis autom√°tico de sus modelos. No
obstante se pueden encontrar, en el √°rea m√©todos formales, numerosos trabajos
que aportan t√©cnicas y herramientas con el fin de formalizar dichos lenguajes. En
general, estas t√©cnicas adoptan alg√∫n lenguaje para modelar procesos de negocios
o parte de ellos, como ciertos diagramas que en ellos se definen, y le brindan una
sem√°ntica formal con soporte en alg√∫n formalismo. Luego, haciendo uso de las
herramientas autom√°ticas o semi-autom√°ticas de dichos formalismos, permiten
analizar propiedades que cumplen los modelos originales. Generalemente estas
propiedades son expresadas en alg√∫na l√≥gica temporal. En [14] podemos encontrar un exhaustivo an√°lisis de √©stos trabajos clasificados seg√∫n los formalismos
en los cuales se basan.
Si bien el an√°lisis, mediante modelos de procesos de negocios, es cada vez m√°s
utilizado para la evaluaci√≥n de organizaciones o para el dise√±o y control en etapas
tempranas de desarrollo, la gran mayoria de los lenguajes actuales para tal fin,
no contienen un objeto que permita especificar productos (una referencia a un
elemento emp√≠rico con propiedades) como un referente expl√≠cito del modelo. La
norma internacional ISO-9001 define un proceso como ‚Äúuna actividad que utiliza
recursos, y que se gestiona con el fin de permitir que los elementos de entrada se
transformen en resultados‚Äù [9]. Creemos que en modelos reales, por ejemplo, en
caso de procesos industriales o modelos en los cuales no exista un intercambio
directo de informaci√≥n entre los procesos, la necesidad de contar con la especifiaci√≥n de productos en el modelo, es tan necesario como las especificaciones de
los procesos que los manipulan. De esta manera, el conjunto de productos del
modelo representan una visi√≥n estructural del estado del sistema a trav√©s del
tiempo, es decir, una especificaci√≥n expl√≠cita de los estados del modelo previos
y posteriores a la realizaci√≥n de uno o mas procesos que lo componen. Adem√°s,
la especificaci√≥n de los productos no s√≥lo ayudan a describir condiciones mas
complejas de composici√≥n de procesos, sino tambi√©n, nos brindan la posibilidad
de analizar el comportamiento de los mismos durante todo el proceso del sistema; por ejemplo la verificaci√≥n de propiedades que deban reunir los productos
al final de una serie de procesos.
Otra caracter√≠stica deseable de un lenguaje para el modelado de procesos de
negocios es la posibilidad de contar con referencias al tiempo, es decir, poder
especificar, en alguna medida temporal, restricciones o condiciones para los procesos o productos modelados. Como se puede observar en [10] pag. 3 y [16] Section 1.7 entre otros, es clara la necesidad de contar con la especificaci√≥n de cotas
temporales para los procesos. Esta informaci√≥n temporal, adem√°s de reflejar
caracter√≠sticas del modelo real, nos brinda la posibilidad de analizar (verificar)
condiciones (propiedades) expresadas en alg√∫na l√≥gica temporal, por ejemplo, si
cierto producto es fabricado respentando l√≠mites de tiempo para garantizar la
calidad de producci√≥n del cierto proceso industrial.
Product Process Modeling Language PPML [11] es un formalismo para el
modelado de procesos de negocios con una sem√°ntica basada en sistemas de
transici√≥n de estados temporizados [8]. Sus modelos se construyen mediante la
especificaci√≥n y composici√≥n de procesos y su interacci√≥n con los productos que
manipulan. PPML ofrece una variedad de elementos, en particular la asignaci√≥n
de cotas temporales a los procesos, que lo hacen adecuado para la especificaci√≥n
formal de procesos en los cuales existan restricciones temporales, sincronizaci√≥n
entre componentes, concurrencia en las tareas, etc. Si bien PPML fu√© definido
en sus comienzos con el objetivo de ser aplicado a la industria, no posee una
sintaxis flexible y amigable para la definici√≥n de sus modelos.
Con el objetivo de ampliar el campo de aplicaci√≥n y facilitar la especificaci√≥n procesos de negocios con PPML, proponemos una sitaxis de alto nivel
para el mismo. Con ella podemos brindar soporte automatizado para el an√°lisis
de sus modelos, como parsers, etc., y asistir mediantes entornos de especificaci√≥n, la creaci√≥n de los mismos. Adem√°s, como se describe en [15], podemos
verificar propiedades termporales de sus modelos, expresadas en Computational
Tree Logic, mediante la utilizaci√≥n de UPPAAL (model checker) [1] como herramienta de soporte.
El trabajo procede de la siguiente manera: Primeramente analizamos diferentes propuestas de formalizaciones de lenguajes y metodolog√≠as para la especificaci√≥n de procesos de negocios. Luego presentamos una descripci√≥n de PPML y
proponemos una sintaxis de alto nivel para el mismo, aplic√°ndola en un caso de
estudio que revela la necesidad de contar con productos como referentes expl√≠citos
del modelo, .
El caso de estudio abordado es un simple sistema de parquimetros para el
estacionamiento medido. En √©l, los individuos que desean estacionar su veh√≠culo
deben tener un llavero magn√©tico que registra su saldo disponible entre otra
informaci√≥n. La operatoria del caso de estudio es la siguiente: cuando arribamos al estacionamiento deseado, dejamos el auto, colocamos el llavero junto al
parquimetro y se inicia el alquiler del espacio, esto es, el parquimetro registra
en el llavero los datos pertinentes, como la hora de inicio e identificador del
parquimetro (este puede medir m√°s de un espacio). Cuando nos retiramos, colocamos nuevamente el llavero junto al parquimetro y √©ste finaliza la transacci√≥n,
descontando del saldo el importe producto del per√≠o de tiempo por el costo del
mismo.
1.1 Trabajos relacionados
Existen en la actualidad diversas propuestas de formalizaciones para lenguajes
para el modelado de procesos de negocios con el fin de poder verificar formalmente propiedades de sus modelos. En [14] podemos encontrar un estudio detallado de diferentes trabajos para verificar formalmente procesos de negocios y una
clasificaci√≥n de los mismos seg√∫n su soporte formal: automatas, redes de Petri
y √°lgebra de procesos. Otro estudio de trabajos para el modelado y an√°lisis de
procesos de negocios es presentado en [5] [6], donde se muestra una traducci√≥n
de modelos de servicios web en UML a FSP, para luego ser analizados usando
la herramienta LTSA.
Tambi√©n existen trabajos con el objetivo de proveer de una sem√°ntica formal
a BPMN (Business Process Modeling Notation), como por ejemplo los presentados en [17] [18]. Dicha sem√°ntica permite el an√°lisis de compatibilidad entre
los procesos de negocios a nivel de dise√±o.
En [12] una traducci√≥n semi-autom√°tica de BPD (Diagramas de procesos de
negocios) a TLA+ es presentada. Con ella, se pueden verificar, mediante el TCL
model checker, propiedades de los procesos de negocios expresadas en f√≥rmulas
TLA.
Como propuestas para la formalizaci√≥n y an√°lisis de workflow languages,
por ejemplo, para diagramas de actividades de UML, podemos citar [7], en la
cual √©stos diagramas son traducidos a PROMELA (lenguaje de especifiaci√≥n de
SPIN model checker). Adem√°s de √©ste, existen numerosos trabajos que proponen
una sem√°ntica formal para workflow languages basados en redes de Petri y sus
extensiones, como redes de Petri temporizadas.
2 Descripci√≥n de PPML
PPML es un formalismo para modelar procesos de negocios, est√° basado en el
m√©todo descripto en [13]. El m√©todo provee tres tipos de construcciones b√°sicas:
productos, procesos y puertas. Los productos son entidades representadas por
un conjunto de atributos. Los procesos son entidades que pueden manipular,
transformar productos. √âstos son caracterizados por su comportamiento en el
tiempo teniendo como restricci√≥n, s√≥lo un producto de entrada y uno de salida.
Como mecanismo adicional para la interconexi√≥n de procesos, PPML provee
puertas que permiten empaquetar, desempaquetar o sincronizar productos.
2.1 Productos
Los productos capturan las caracter√≠sticas relevantes del modelo emp√≠rico, por
ejemplo altura, peso, color, etc. Estas caracter√≠sticas pueden ser directamente
observables o calculables a partir de otras mediante funciones, adem√°s son determinadas en base a una escala apropiada. Debido al requerimiento de poder
empaquetar productos, necesitamos una clase de productos compuestos; √©stos no
representan ning√∫n referente emp√≠rico, s√≥lo es un mecanismo del m√©todo para tal
fin. Otra clase de productos que proporciona PPML, son los productos estructurados, los cuales pueden ser refinados (especializaciones de otros productos) o
agregados (contienen productos como sus componentes).
Definimos un producto at√≥mico como una tupla „Äàcodigo, nombre, tiempo,
atributos, „ÄàŒ£,A„Äâ„Äâ donde: codigo y nombre son constantes de los conjuntos Codigo
yNombre respectivamente, tiempo es una constante del conjunto Time, atributos
es un conjunto de constantes de Œ£. Los atributos pueden ser directos o derivados, √©stos √∫ltimos obtienen su valor a partir de otros por medio de axiomas
especificadoes en A. Llamamos a „ÄàŒ£,A„Äâ la teor√≠a de presentaci√≥n del producto,
que consta de la signatura Œ£, que contiene todas las constantes definidas en el
producto y A el conjunto de axiomas que rigen su comportamiento. Definimos
una instancia de un producto como una interpretaci√≥n en el sentido l√≥gico de
„ÄàŒ£,A„Äâ.
En caso de un producto compuesto, o bien, es un par „Äàcodigo‚äó (Pc1, .., Pcn)„Äâ
donde ‚äó(Pc1, .., Pcn) es una inyecci√≥n de los componentes Pci en el producto
cartesiano; o bien, un es par „Äàcodigo, Œπ(P)„Äâ donde P es un conjunto finito de
productos y Œπ(P) ‚àà P. √âste √∫ltimo utilizado en situaciones donde el producto
de entrada es elegido en base a una condici√≥n.
Un producto estructurado puede ser especializado ( se extiende uno definido
agregando nuevas constantes, funciones y relaciones) o agregado (permite combinar varios productos como constituyentes de un nuevo producto). Los atributos
de los productos agregados pueden ser atributos de sus constituyentes o nuevos
atributos.
Como ejemplo, supongamos que queremos modelar parte del caso de estudio propuesto, en particular, el producto que formaliza un llavero magn√©tico. El
llavero contiene como propiedades: los posibles estados en los que se puede encontrar (Parked, Not-parked), el saldo (importe) disponible, la hora de comienzo
de estacionamiento, el identificador del parquimetro en donde est√° estacionado
y el costo por hora del mismo.
„ÄàCode,KeyChain, T ime, [status, balance, start time, parkingID, cost hour], „ÄàŒ£,A„Äâ„Äâ
Figura 1. Producto KeyChain
Donde Code es un c√≥digo para identificar a este producto, KeyChain es el
nombre del producto y Time registra el momento en que fueron actualizados por
√∫ltima vez sus atributos. El conjunto de atributos status, balance, start time,
parkingID, cost hour representan las propiedades que deseamos modelar. En
„ÄàŒ£,A„Äâ, A tiene como axioma status ‚Üí balance > 0, especificando la necesidad
de contar con saldo positivo en el llavero para poder estacionar (especificamos
el estado como dos posibles valores de status, ‚Äúverdadero‚Äù est√° estacionado y
‚Äúfalso‚Äù no lo est√°).
2.2 Procesos
Un proceso modela un referente emp√≠rico que transforma un producto de entrada
en uno de salida. Al igual que los productos, los procesos pueden ser at√≥micos
(sin estructura interna o subprocesos) o estructurados. Los procesos modelan
transformaciones, para ello, por cada proceso existe una m√°quina virtual que
interpreta sus comandos b√°sicos. Esta m√°quina virtual es un objeto con m√©todos,
por ejemplo, asignaci√≥nes a variables. Para especificar un proceso, definimos las
transformaciones que √©ste realiza usando acciones b√°sicas o combinaciones de
estas por medio de estructuras de control. La formalizaci√≥n del concepto de
m√°quina virtual [4] consiste en un framework l√≥gico sobre sistemas de transici√≥n
de estados llamado RETOOL [3].
La especificaci√≥n de un proceso es una transacci√≥n, un segmento de computaci√≥n de la m√°quina virtual subyacente. Consta de la condici√≥n inicial q (estados que satisfacen las precondiciones para llevar a cabo el proceso), la condici√≥n
final p (estados que satisfacen la condici√≥n final del proceso), el invariante I (sentencia que debe evaluarse verdadera en todos los estados de la traza) y las cotas
inferior y superior (l, u) que especifican el tiempo m√≠nimo y m√°ximo que puede
demorar el proceso en completarse. Formalmente, dada una secuencia de estados
temporizados „ÄàœÉ, T „Äâ, donde œÉ una traza posiblemente infinta de estados y T es
una secuencia de tiempos correspondientes a œÉ, e i un estado de la misma (estado actual), especificamos un proceso con la f√≥rmula (q, I)l‚àÜup, y su sem√°ntica:
œÉ, T, i  (q, I)l‚àÜup si y s√≥lo si para alg√∫n j, k tal que i + 1 ‚â§ j < k ‚â§ i + u,
tenemos para cada i ‚â§ m ‚â§ j que œÉ, T,m  q; œÉ, T, k  p, y para cada j ‚â§ n ‚â§ k
tenemos œÉ, T, n  I.
Definimos un proceso at√≥mico como un par P = „Äàproc, V M„Äâ, donde VM =
„ÄàŒ∏,Œò„Äâ y proc = „Äàcodigo, nombre, Pin, Pout, (q, I)l‚àÜup„Äâ, donde codigo y nombre
identifican y dan nombre al proceso respectivamente, adem√°s son fijos, es decir,
no cambian durante las trazas de c√≥mputo. Pin, Pout son los productos de entrada
y salida, y (q, I)l‚àÜup es la especificaci√≥n del comportamiento del proceso.
Como ejemplo, se muestra el proceso estacionar (Fig.2), es decir, iniciar
el alquiler el espacio de estacionamiento. Este proceso recibe como entrada el
llavero electr√≥nico y el parquimetro y devuelve el llavero con la modificaciones
correspondientes: el estado ahora es estacionado (Parked), parkingID contiene
el identificador del parquimetro seleccionado y cost hour el costo por hora del
mismo.
„ÄàCode, Start Panking,‚äó„ÄàKeyChain, ParkingMeter„Äâ,KeyChain, (q, I)l‚àÜup„Äâ
q : Keychain.status = NotParked ‚àßKeychain.balance > 0.
p : Keychain.status = Parked‚àßKeychain.start time = ParkingMeter.current time
‚àßKeychain.parkingID = ParkingMeter.id. I : true. l : 2. u : 10.
Figura 2. Proceso que especifica el inicio de un alquiler de estacionamiento
La pre-condici√≥n exige que el llavero tenga un saldo positivo y que su estado
indique la disponibilidad de estacionar. Como pos-condici√≥n el llavero queda
afectado al estado de ‚Äúestacionado‚Äù y se especifica en el la hora de comienzo
de alquiler. Cabe destacar que, si bien el m√©todo provee acciones o variables
controladas por el ambiente, en este caso, asumimos que todos los parquimetros
tienen sincronizados un reloj interno indicando la hora actual. Las cotas l y u
especifican que el parquimetro tardar√° almenos 2 unidades de tiempo en realizar
la transacci√≥n y no demorar√° mas all√° de 10 unidades de tiempo, (e.g. para
iniciar el estacionamiento no podemos esperar, por parte del usuario, m√°s de 10
segundos sin perder la paciencia).
2.3 Puertas
Usaremos el concepto de puertas como herramienta que provee el formalismo
para interconectar procesos, i.e. para especificar situaciones complejas de conexi√≥n
entre los procesos, por ejemplo, cuando un proceso manipula varios productos, para distribuir varios productos, o para sincronizar productos bajo cierta
condici√≥n. Existen tres tipos b√°sicos de puertas: multiplexor, demultiplexor y
sem√°foro, cada uno de ellos con su interpretaci√≥n esperada, gr√°ficamente:
P1
...
Pn
M
P
Figura 3. Multiplexor
P
D
P1
...
Pn
Figura 4. Demultiplexor
P
S
P
Figura 5. Sem√°foro
2.4 Composici√≥n de procesos
En el proceso de modelar sistemas, al igual que en programaci√≥n, necesitamos herramientas para poder componer procesos. Para ello, PPML provee las
siguientes estructuras de procesos: Sean p1 = „Äàp1code, p1name, p1I , p1O,
(qp1, Ip1)lp1‚àÜ
up1pp1„Äâ y p2 = „Äàp2code, p2name, p2I , p2O, (qp2, Ip2)lp2‚àÜ
up2pp2„Äâ dos
procesos,
‚Äì Composici√≥n secuencial : Denotada por p1; p2, combina dos procesos en un
nuevo proceso p = „Äàcode, name, p1I , p2O, (qp1, Ip)lp1‚àÜ
up1+up2pp2„Äâ. Donde code
y name tienen nuevos valores para identificarlo y el invariante Ip est√° definida
por q1U>lp1(Ip1U‚â§up1‚àílp1(pp1 ‚áí true U(qp2U>lp2(Ip2U‚â§up2‚àílp2pp2)))).
‚Äì Composici√≥n condicional : Denotada por p1;s p2, es an√°loga a la composici√≥n
secuencial, pero con el invariante
qq1U>lp1(Ip1U‚â§up1‚àílp1(pp1 ‚áí trueU((qp2 ‚àß Ss)U>lp2(Ip2U‚â§up2‚àílp2pp2)))),
donde Ss es una expresi√≥n condicional que debe ser verdadera para que p2
pueda comenzar.
‚Äì Composici√≥n Paralela: Sean mO = „Äàmultiplexer code,PO, PO, FO„Äâ y dI =
„Äàdemultiplexer code, PI ,PI , FI„Äâmultiplexor y demultiplexor, cada uno definido
sobre los productos de entrada y salida de p1 and p2 respectivamente. La
composici√≥n paralela p de p1 y p2 respecto de mO y dI , denotada por
[p1; p2](dI ,mO), est√° definida por: codigo y nombre an√°logos a las definiciones anteriores. La entrada de p es la del demultiplexor dI , la salida
es la del multiplexor mO. La funci√≥n de transferencia œÑ de p es (qp1 ‚àß
qp2, Ip)max((lp1,lp2))‚àÜ
max((up1,up2))(pp1‚àßpp2), donde el invariante Ip est√° definido
por (qp1 ‚àß qp2) ‚áí (œÑ1[(pp1U(pp1 ‚àß pp2))/pp1] ‚àß (œÑ2[(pp2U(pp1 ‚àß pp2))/pp2]))
(donde œÑ [(pUq)/r] denota el reemplazo de la condici√≥n final r en œÑ por la
condici√≥n (pUq)). Esto especifica que cuando los procesos est√°n habilitados
para comenzar, realizan su trabajo en paralelo y luego de que uno de ellos
termina, debe esperar que el segundo finalice su tarea.
3 Sintaxis y extensiones de PPML
En trabajos previos de PPML, todos los elementos que forman parte de la especificaci√≥n de un modelo, son definidos formalmente. Con el objetivo de brindar un
modo de especificar modelos PPML en un nivel menos riguroso, proponemos una
sintaxis para los productos, procesos y puertas. Esta sintaxis tiene dos objetivos:
proveer una forma m√°s flexible y accesible de escribir especificaciones en PPML
(como en otros lenguajes de modelado de procesos de negocios) y estandarizar el
lenguaje con el objetivo de poder construir herramientas para el lenguaje como
parsers, analizadores, asistentes, etc.
Por cuestiones de espacio, mostraremos la sintaxis aplic√°ndola al caso de
estudio propuesto. Para los productos, la sintaxis se muestra en la Fig. 6.
Product KeyChain {
boolean status,
float balance,
time start_time,
int parkingID,
float cost_hour
axioms: status imply ( balance > 0)
}
Figura 6. Producto KeyChain
Cabe destacar que si bien se proponen los tipos para cada atributo, la actual
versi√≥n de traducci√≥n [15] para verificar propiedades de los modelos no contempla
tipos como float. En caso de ser un producto estructurado, es decir, un producto
definido a partir de otros como sus componentes, se declara el atributo con
el nombre del producto como su tipo, por ejemplo, si el llavero tuviera como
componente un led para indicar su saldo actual (color verde para saldo positivo
y rojo para negativo ), deber√≠amos agregar en la definici√≥n anterior ‚Äúled indicator
‚Äù junto con la especificaci√≥n del producto led. Para modelar el comportamiento
del mismo deber√≠amos agregar el axioma, ‚Äú ((balance >= 0) and (indicator.color
= 1)) or ((balance ¬° 0) and (indicator.color = 2)) ‚Äù, donde ‚Äú1‚Äù y ‚Äú2‚Äù representa
luz verde y roja respectivamente.
Cuando modelamos procesos de negocios existen situaciones en las cuales
cierto producto es procesado en diferentes etapas o cuando alguno de sus componentes no est√°n definidos en determinados momentos del sistema. En estas
situaciones es necesario contar con valores nulos que permitan especificarlas.
Para describir la sintaxis de los procesos, especificaremos los procesos de
comienzo y finalizaci√≥n del alquiler del estacionamiento. El primero de ellos
(Fig.7) espera un producto compuesto que contiene el llavero y el parquimetro,
como pre-condici√≥n requiere que el saldo sea mayor que cero y que su estado
indique su disponibilidad para estacionar. Como resultado, devuelve el llavero
actualizado, esto es, con el idenficador del parquimetro, la hora de comienzo
y su estado como ‚Äúestacionado‚Äù. Los l√≠mites de tiempo indican que el proceso
demorar√° almenos 2 unidades de tiempo (segundos) y como m√°ximo 10 unidades.
El proceso de finalizaci√≥n (Fig.8), espera nuevamente como un producto compuesto, un llavero y un parquimetro. Requiere que el llavero indique un estado
‚Äúestacionado‚Äù y que el identificador del parquimetro donde inici√≥ el alquiler sea
igual a identificador del parquimetro de entrada. Como resultado devuelve el
llavero descontando del saldo, el importe correspondiente al alquiler que finaliza
y restaurando el estado del llavero para futuros alquileres. Cabe destacar que,
si bien el saldo pudiera quedar negativo, inhabilitar√≠a al mismo hasta que se le
realice una recarga.
Process StartPanking {
input: [KeyChain KeyC_in; ParkingMeter ParkingM_in]
output: KeyChain KeyC_out
invariant: true
requires: not KeyC_in.status and KeyC_in.balance $>$ 0
ensure: KeyC_out = KeyC_in and KeyC_in.status = true and
KeyC_in.start_time = ParkingM_in.current_time and
KeyC_in.parkingID = ParkingM_in.id
l_time: 2 u_time: 10
}
Figura 7. Proceso que especifica el comienzo de un alquiler de estacionamiento
Process EndPanking {
input: [KeyChain KeyC_in; ParkingMeter ParkingM_in]
output: KeyChain KeyC_out
invariant: true
requires: KeyC_in.status and KeyC_in.parkingID = ParkingM_in.id
ensure: KeyC_out = KeyC_in and KeyC_in.status = false and
KeyC_in.balance = KeyC_in.balance - (ParkingM_in.cost_hour *
(ParkingM_in.current_time - KeyC_in.start_time) / 60)
l_time: 2 u_time: 10
}
Figura 8. Proceso que especifica la finalizaci√≥n del alquiler de un estacionamiento
Como podemos observar, la finalizaci√≥n del alquiler deber realizarse sobre el
mismo parquimetro donde se comenz√≥ la misma. Esta restricci√≥n podr√≠a flexibilizarce permitiendo que las personas que olvidan finalizar el alquiler y se retiran, puedan cerrar la operaci√≥n en otro parquimetro. Para ello, el proceso
StartParking deber√≠a modificar el atributo ‚Äúcost hour‚Äù del llavero, as√≠ cuando
se cierra el alquiler en otro parquimetro, √©ste puede descontar correctamente el
costo.
4 Conclusiones y Trabajos Futuros
Hemos analizado exhaustivamente el estado del arte del √°rea de m√©todos formales que persigue como objetivo brindar soporte formal a la especificaci√≥n de
procesos de negocios, particularmente notamos que la gran mayor√≠a de lenguajes para tal fin, no provee elementos dentro del lenguaje que permita modelar
productos (entidades del modelo). Por ello, retomamos un formalismo para la
especifiaci√≥n de procesos de negocios y lo adaptamos para facilitar y extender su
aplicaci√≥n. Focalizamos nuestro inter√©s en investigar las ventajas de contar con
‚Äúproductos‚Äù como elementos lenguaje y para ello mostramos un caso de estudio
que revela dicha necesidad. Actualmente estamos trabajando en un prototipo
de entorno para asistir la creaci√≥n de modelos PPML, para luego integrar en
√©l diferentes herramientas de an√°lisis para los mismos. Por otra parte, estamos
investigando la posibilidad de dotar a PPML con transacciones, es decir, poder
especificar en sus modelos, que diferentes procesos que realizan cambios en los
productos que manipulan, o bien, se concretan los exitosamente, o bien los productos intervinientes deben quedar en su estado inicial, previo al primero de
dichos procesos. Para ello se est√°n estudianto diferentes t√©cnicas formales para
su tratamiento como por ejemplo compensaciones [2].
