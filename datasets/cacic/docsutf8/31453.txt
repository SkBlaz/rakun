IP core para redes de Petri con tiempo
ï»¿ En este trabajo, se presenta un procesador de Redes de Petri con 
Tiempo, el que es la evoluciÃ³n del Procesador de Petri Temporizado. Este 
procesador es programado directamente con las matrices y vectores del 
formalismo de Petri, lo que permite aprovechar el poder de las redes de Petri para 
modelar sistemas de tiempo real y verificar formalmente sus propiedades, 
evitando errores de programaciÃ³n al implementar el programa a ejecutar. 
Este desarrollo ha sido realizado como un IP-cores y es usado en un sistema 
Multi-core. De esta manera, es posible realizar la implementaciÃ³n del sistema 
utilizando este IP-core, lo que asegura las propiedades del modelo realizado con 
la red de Petri con Tiempo, que verifican los requerimientos del modelo que 
representa al sistema real, sean cumplido. 
Key words: Multi-core, Red de Petri, Procesador 
1 IntroducciÃ³n 
Los sistemas informÃ¡ticos son complejos tanto en su estructura como en su 
comportamiento, mÃ¡s aun cuando tienen un gran nÃºmero de estados y numerosas 
combinaciones de datos y eventos de entrada. 
Abordar soluciones de sistemas complejos y crÃ­tico, para dar soluciÃ³n a sistemas en 
tiempo real, tiene problemas como: la complejidad inherente de la especificaciÃ³n, la 
coordinaciÃ³n de tareas concurrentes, la falta de algoritmos portables, entornos 
estandarizados, software y herramientas de desarrollo.  
Y teniendo en cuenta, las tendencias inequÃ­vocas en el diseÃ±o de hardware, que 
indican que un solo procesador no puede ser capaz de mantener el ritmo de incrementos 
de rendimiento. Por lo que la evoluciÃ³n de los procesadores, que es consecuencia de la 
mayor integraciÃ³n y la composiciÃ³n de distintos tipos de funcionalidades integradas en 
un Ãºnico procesador. MÃ¡s aun, hoy la disponibilidad de transistores ha hecho factible 
construir en una sola pastilla varios nÃºcleos de procesador que ha resultado en el 
desarrollo de la tecnologÃ­a Multi-core [1]. 
La obtenciÃ³n de rendimiento decreciente del paralelismo a nivel de instrucciÃ³n (ILP) 
y el costo del incremento en la frecuencia debido principalmente a las limitaciones de 
potencia (se sugiere que un 1% de aumento de velocidad de reloj resultados en un 
aumento de potencia del 3% [2]) ha motivado el uso de los Multi-core. 
1097
Por lo cual los procesadores Multi-core son una propuesta para obtener aumento de 
rendimiento. Lo que se traduce principalmente en menores tiempos de ejecuciÃ³n, 
consumo ruido, densidad de energÃ­a, latencia y mÃ¡s ancho de banda en las 
comunicaciones inter-core. Si tambiÃ©n consideramos a los Multi-core heterogÃ©neos que 
tienen como ventaja emplear cores especializados, diseÃ±ados para tareas especÃ­ficas. 
Es decir, optimizado segÃºn la necesidad. Estos tienen la capacidad de usar los recursos 
de hardware disponibles donde el software especÃ­ficamente lo requiere. [3] 
Con el fin de aumentar el desempeÃ±o, estos sistemas hacen uso colaborativos de 
multi-hilos y/o multi-tarea, lo que permite aprovechar los mÃºlti-nÃºcleos. Pero se 
requiere de mÃ¡s trabajo en el diseÃ±o de las aplicaciones, ya que emergen con fuerza la 
problemÃ¡tica de los sistemas concurrentes. 
Por lo que con estos procesadores, la programaciÃ³n paralela es indispensable para la 
mejora del desempeÃ±o del software en todos los segmentos de desarrollo y con mÃ¡s 
razÃ³n en el segmento de sistemas de tiempo real. 
Para dar soluciÃ³n a los sistemas reactivos, paralelos y de tiempo real, en relaciÃ³n con 
los siguientes aspectos: 
ï‚· Problemas de concurrencia que emergen en la programaciÃ³n paralela, por no ser 
componible, es decir, no se puede obtener un programa paralelo de la composiciÃ³n 
directa de dos programas secuenciales. 
ï‚· Que el hardware de soporte a la implementaciÃ³n de sistemas concurrentes, 
permitiendo mejorar los algoritmos paralelos. 
ï‚· Asegurar los requerimientos temporales en los sistemas de tiempo real, es decir, los 
intervalos mÃ­nimos y mÃ¡ximos para la ocurrencia de un evento. Para lo cual el 
hardware facilite la programaciÃ³n de estas restricciones en forma directa. 
ï‚· Tareas de codificaciÃ³n, que se requieren para la implementaciÃ³n de un modelo, 
conducen a errores e incrementan el esfuerzo, por lo que es muy valorable que no 
exista ninguna tarea entre el modelo y el software a ejecutar. 
2 Objetivo 
2.1 Objetivo Principal 
El objetivo principal de este trabajo es diseÃ±ar e implementar un procesador de Redes 
de Petri con Tiempo, que ejecute la semÃ¡ntica temporal y se programe en forma directa 
a partir de las ecuaciones de estado del modelo. 
2.2 Objetivos Secundarios 
Los objetivos secundarios de este trabajo son:  
ï‚· Describir brevemente las Redes de Petri con Tiempo con el fin de realizar su 
implementaciÃ³n por hardware. 
ï‚· Mantener la ejecuciÃ³n de las Redes de Petri ordinarias con parÃ¡metros temporales 
en dos ciclos de reloj.  
ï‚· Implementar el procesador de Redes de Petri en un IP-core. 
1098
3 Redes de Petri con Tiempo 
En estas redes, cada transiciÃ³n con tiempo tiene asociado un intervalo de tiempo [a, 
b] que establece el intervalo de tiempo dentro del cual puede ser disparada la transiciÃ³n, 
con el fin de homogenizar las definiciÃ³n matemÃ¡tica definimos  transiciones inmediatas 
con lÃ­mite inferior cero. [4] 
3.1 DefiniciÃ³n MatemÃ¡tica 
Una Red de Petri con Tiempo (TPN)  [5] y marcada, se define matemÃ¡ticamente 
como una 8-tupla de la siguiente manera: 
{ğ‘ƒ, ğ‘‡,  ğ¼+,  ğ¼âˆ’, ğ», ğ¶,ğ‘š0, ğ¼ğ‘† } 
 
Donde {ğ‘ƒ, ğ‘‡,  ğ¼+,  ğ¼âˆ’, ğ», ğ¶,ğ‘š0} es una red de Petri plaza transiciÃ³n marcada con 
brazos inhibidores y plazas acotadas, y ğ¼ğ‘† es la funciÃ³n estÃ¡tica de intervalos [ğ‘, ğ‘] 
asociados a cada transiciÃ³n.  
DÃ³nde:  
ğ‘·: es un conjunto finito y no vacÃ­o de plazas. 
ğ‘»: es un conjunto finito y no vacÃ­o de transiciones, P y T son conjuntos disjuntos  
 ğ‘°+,  ğ‘°âˆ’ : son las matrices de incidencia positiva y negativa. La matriz ğ‘° es las 
diferencias entre  ğ‘°+,  ğ‘°âˆ’. 
ğ‘ƒğ‘¥ğ‘‡ â†’  ğ‘ 
H: es la matriz de brazos inhibidores. 
ğ‘ƒğ‘¥ğ‘‡ â†’ {0,1} 
C: es el vector de cota de plaza 
ğ¶ â†’ ğ‘ 
IS: es la funciÃ³n estÃ¡tica de intervalos asociados a cada transiciÃ³n.  
ğ‘‡ â†’ â„š+ Ã— (â„š+ âˆªâˆ) 
La funciÃ³n IS asocia a cada transiciÃ³n un par de valores que representan los lÃ­mites 
temporales mÃ¡ximÃ³ y mÃ­nimo entre los cuales la transiciÃ³n podrÃ¡ ser disparada. De 
manera tal que 
ğ¼ğ‘†(ğ‘¡) =  [ğ‘šğ‘–ğ‘›,ğ‘šğ‘ğ‘¥] âˆ€ ğ‘¡ âˆˆ ğ‘‡ 
 
Como la funciÃ³n IS representa un intervalo temporal, para cada transiciÃ³n t 
sensibilizada se introduces el valor ğ‘¡ğ‘–ğ‘šğ‘’ğ‘Ÿğ‘¡ , que se auto incrementa con el tiempo, si la 
transiciÃ³n esta sensibilizada y se cumplir: min â‰¤  ğ‘¡ğ‘–ğ‘šğ‘’ğ‘Ÿğ‘¡  â‰¤ ğ‘šğ‘ğ‘¥ el disparo sea 
posible. 
Estas cotas deben cumplir las siguientes condiciones: 
ï‚· 0 â‰¤ min < âˆ 
ï‚· 0 â‰¤ max â‰¤ âˆ 
ï‚· ğ‘šğ‘–ğ‘› â‰¤ max ğ‘ ğ‘– max â‰  âˆ 
ï‚· ğ‘šğ‘–ğ‘› < max ğ‘ ğ‘– max = âˆ 
1099
Al valor min lo lamamos Earliest Firing Time EFT (Instante de disparo mÃ¡s 
temprano). Y, al valor max se le llama Latest Firing Time LFT (Instante de disparo mÃ¡s 
tardÃ­o). 
Existen dos tipos de intervalos destacables: 
ï‚· Intervalo puntual [ğ‘, ğ‘]. En este caso, el tiempo de disparo es fijo, despuÃ©s de 
sensibilizaciÃ³n se espera un tiempo ğ‘. 
Un disparo inmediato es representado por Î± = 0 y se comporta como en las Redes de 
Petri plaza transiciÃ³n. 
ï‚· Intervalo sin restricciÃ³n temporal, [ğ‘,âˆ]. Se disparara en algÃºn momento despuÃ©s 
de sensibilizarse y un tiempo a. 
3.2  Estados en una Red de Petri Temporizada 
En las Redes de Petri con tiempo, el estado de la red es definido por el vector de 
marcado ğ‘šğ‘– y por el vector de valores de intervalos de transiciÃ³n ğ‘¡ğ‘–ğ‘šğ‘’ğ‘Ÿ de la red, que 
lleva la cuenta de tiempo de cada transiciÃ³n sensibilizada. Por lo tanto el estado es:  
ğ¸ =  (ğ‘šğ‘–, ğ‘¡ğ‘–ğ‘šğ‘’ğ‘Ÿ ) 
3.3 TransiciÃ³n Sensibilizada y Disparo de una TransiciÃ³n 
Cundo nos referimos a una transiciÃ³n hay que distinguir las siguientes cuestiones: 
transiciÃ³n habilitada o sensibilizada, transiciÃ³n no habilitada y disparo de una 
transiciÃ³n. 
En una Red de Petri marcada, con una marca ğ’ğ’Œ, se dice que una transiciÃ³n tj se 
encuentra habilitada o sensibilizada si y solo si (sii) todos los lugares del conjunto de 
plazas â€¢ tj de entrada a la transiciÃ³n tienen al menos la cantidad de marcas igual al peso 
de los arcos ( ğ’˜(ğ’‘ğ’Š, ğ’•ğ’‹)) de entrada a la transiciÃ³n tj, esto es:  
 
 ğ‘ğ‘– âˆˆ   â€¢ ğ‘¡ğ‘– , ğ‘š(ğ‘ğ‘—) â‰¥ ğ‘¤(ğ‘ğ‘– , ğ‘¡ğ‘—) 
 
Si el ğ‘¡ğ‘–ğ‘šğ‘’ğ‘Ÿ de la transiciÃ³n es cero, se debe habilitar ğ‘¡ğ‘–ğ‘šğ‘’ğ‘Ÿğ‘¡  para que se auto 
incremente con el tiempo. 
Las transiciones sensibilizadas pueden ser disparadas en el intervalo [a, b], y su 
disparo provoca un nuevo marcado es decir un cambio de estado. La ecuaciÃ³n para 
calcular el cambio de estado o la nueva marca alcanzada por el disparo de tj es 
ğœ• (ğ‘šğ‘˜ , ğ‘¡ğ‘—), y se define por la siguiente expresiÃ³n: 
ğœ• (ğ‘šğ‘˜, ğ‘¡ğ‘–ğ‘šğ‘’ğ‘Ÿğ‘¡) =
{
 
 
ğ‘šğ‘˜+1(ğ‘ğ‘–) =  ğ‘šğ‘˜(ğ‘ğ‘–) âˆ’ ğ‘¤ğ‘–ğ‘—   
ğ‘šğ‘˜+1(ğ‘ğ‘–) =  ğ‘šğ‘˜(ğ‘ğ‘–) + ğ‘¤ğ‘—ğ‘–   
min â‰¤  ğ‘¡ğ‘–ğ‘šğ‘’ğ‘Ÿğ‘¡  â‰¤ ğ‘šğ‘ğ‘¥         
ğ‘šğ‘˜+1(ğ‘ğ‘–) =  ğ‘šğ‘˜(ğ‘ğ‘–)  
 
, âˆ€ ğ‘ğ‘– âˆˆ  ğ‘¡ğ‘— â€¢
, âˆ€ ğ‘ğ‘– âˆˆ  ğ‘¡ğ‘— â€¢
, ğ‘’ğ‘› ğ‘’ğ‘™ ğ‘Ÿğ‘’ğ‘ ğ‘¡ğ‘œ ğ‘‘ğ‘’ ğ‘™ğ‘œğ‘  ğ‘ğ‘ğ‘ ğ‘œğ‘ ;
 
ğ‘šğ‘–ğ‘› = ğ‘,ğ‘šğ‘ğ‘¥ = b  
Donde el ğ‘¡ğ‘–ğ‘šğ‘’ğ‘Ÿğ‘¡ğ‘—se incrementa en cada ciclo de reloj mientras la transiciÃ³n se 
encuentra sensibilizada. 
1100
4 Arquitectura y Funcionamiento del Procesador de Petri con 
Tiempo 
El procesador ejecuta la ecuaciÃ³n de cambio de estado resolviendo solo un disparo 
de una transiciÃ³n a la vez, esto permite resolver todos los casos de disparos, los simples 
(disparo Ãºnico) y los disparos mÃºltiples, realizÃ¡ndolos como una secuencia de disparos 
simples, esto simplifica el hardware.  
Las disparos son transmitidos por los hilos que se ejecutan en los cores a travÃ©s del 
bus del sistema, segÃºn las solicitudes emergentes del sistema que se estÃ¡ ejecutando. 
Esto disparos son recibidos por el Procesador de Petri con Tiempo y almacenado en la 
cola de disparos de entrada. Existe una cola FIFO por cada transiciÃ³n, la salida de este 
conjunto de colas es una palabra con tamaÃ±o igual a la cantidad de transiciones, la cual 
tiene unos en las posiciones correspondientes a las transiciones con disparos solicitados, 
el orden del bit en la palabra es igual al nÃºmero de la transiciÃ³n que solicita el disparo. 
Los bits, que se corresponden con las transiciones que no tiene disparo solicitado, son 
cero, es decir no hay solicitud de disparo.  
La cola de salida tiene una estructura similar, pero comunica los disparos resueltos a 
los hilos. 
En la Fig. 1 se muestran los distintos mÃ³dulos que componen el procesador, 
resaltando las principales diferencias con versiones anteriores. [6] 
El mÃ³dulo de I/O Datos gestiona el acceso de los cores a las matrices y vectores que 
programan el sistema.  
Bus del Sistema Multi-Core
Cola de 
Salida
Cola de 
Entrada
I/O Datos
Ma riz I Matriz H
Cotas de 
Plazas
Transicion
es Auto
Vector 
EFT
Vector 
LFT  
Vector
Timer
Marcado
Estado de 
TransiciÃ³n
Matriz Cal 
proximo estado
Estado 
Sensibilizado 
Detect Red 
Activa
 Matriz de 
Prioridad
Modulo de 
Calculo de la 
EcuaciÃ³n de 
Estado
Fig. 1. Procesador de Petri con Tiempo. 
El programa del sistema son las matrices y vectores descriptas en la ecuaciÃ³n de 
estado, esto permite programar el procesador en forma directa a partir de la Red de Petri 
con Tiempo. 
AquÃ­ se han agregado la matriz de Brazos Inhibidores y el vector de Cota de Plaza 
que no figuran en la ecuaciÃ³n de estado presentada en este trabajo, pero son los mismos 
que en el Procesador de Petri presentado en otros trabajos [7]. 
1101
La responsabilidad del MÃ³dulo de CÃ¡lculo de la EcuaciÃ³n de estado es la siguiente: 
1. Calcular el nuevo estado que resultarÃ­a por disparar solamente una transiciones una 
vez, por lo que resultan tantos vectores de estados calculados como transiciones, y 
se almacenan. Esto se realiza en paralelo sumando al estado actual a cada columna 
de I y almacenando todos los vectores resultantes, los que serÃ¡n evaluados para 
determinar si son los posibles nuevos estado. Esta operaciÃ³n es realizada siempre 
que cambia el estado del procesador, vector Marcado. 
2. Determinar que transiciÃ³n esta sensibilizada. Se toma todos los vectores calculados 
en 1 y se verifica que se cumpla que ninguna plaza tenga marcado negativo y 
tampoco supere la cota de plaza, estas son las transiciones sensibilizadas. 
3. Se arranca o para los Timerğ‘¡  . Si en una transiciÃ³n sensibilizada Timerğ‘¡ = 0 se 
arranca Timerğ‘¡  y si Timerğ‘¡ â‰  0 no se hace nada.  
4. Disparo de una transiciÃ³n. Las transiciones que cumplen con: 
 
ğ‘‰ğ‘’ğ‘ğ‘¡ğ‘œğ‘Ÿ ğ¸ğ¹ğ‘‡ â‰¤  Vector Timerğ‘¡  â‰¤ ğ‘‰ğ‘’ğ‘ğ‘¡ğ‘œğ‘Ÿ ğ¿ğ¹ğ‘‡  
Las transiciones que cumplen con esta condiciÃ³n y han recibido por la cola de 
entrada un disparo o el disparo estÃ¡n programado como automÃ¡tico, conforman un 
conjunto de disparos posibles 
De este conjunto se selecciona el de mayor prioridad y se ejecuta la transiciÃ³n. 
SegÃºn la transiciÃ³n ejecutada se actualiza el vector de estado, y se pone Timerğ‘¡  
a cero. 
5. Se ejecuta como un ciclo continuo los pazos 1, 2, 3 y 4. 
El sistema posee una unidad que detecta cuando ninguna transiciÃ³n esta sensibilizada 
y Vector Timer supera el tiempo mÃ¡ximo; esta condiciÃ³n genera una interrupciÃ³n que 
comunica que el sistema ha finalizado o esta interbloqueado, esta caracterÃ­stica es de 
suma utilidad para verificar el diseÃ±o e implementaciÃ³n del sistema. 
La Tabla 1 muestra las diferencias significativas, desde el punto de vista de la 
ejecuciÃ³n de las distintas semÃ¡nticas, estas son: 
Tabla 1. ComparaciÃ³n entre SemÃ¡nticas Temporales. 
  Con Tiempo Temporizada 
1 Interrumpible Si No 
2 Representa las dos semÃ¡nticas Si No 
3 Matrices usadas I I+, I- 
4 Permite contener subredes No Si 
 
De este cuadro se desprenden las siguientes observaciones:  
1. Siendo que las TPN son interrumpibles y las Redes de Petri Temporizadas (TdPN) 
no lo son, para el caso de mÃºltiples disparos y transiciones en conflicto, un TPN lo 
resuelve segÃºn el intervalo de tiempo; en cambio una TdPN lo hace explÃ­citamente 
en la matriz de prioridad. Esto hace mÃ¡s complejo el modelado con TdPN e 
indispensable incluir en el procesador una matriz de prioridades. 
1102
Dado que la mecÃ¡nica de ejecuciÃ³n de las TdPN requiere de un estado mÃ¡s para 
no ser interrumpibles los tokens son retirados inmediatamente de la plaza y no 
pueden ser solicitados por otra transiciÃ³n. 
2. Dada una red con TPN, una transiciÃ³n, que por semÃ¡ntica es interrumpible, puede 
transformarse en una no interrumpible modificando la red. Esto se logra encerrando 
con una transiciÃ³n inmediata la transiciÃ³n temporiza. Lo que tiene como impacto un 
incremente de una plaza y una transiciÃ³n adicional por cada transiciÃ³n no 
interrumpible. 
3. Para realizar el cÃ¡lculo de un nuevo estado las TPN lo hacen con una matriz de 
enteros con signo mientras que las TdPN lo realizan con dos matrices de enteros sin 
signo; por lo cual debemos analizar dos casos: 
a. Si los pesos de los arcos son uno: 
i. Las TPN requieren de una matriz con 2 bit por elemento. 
ii. Las TdPN requieren de dos matrices binarias. 
b. Si los pesos de los arcos son uno o mayor a uno: 
i. Las TPN requieren de una matriz de enteros con signo. 
ii. Las TdPN requieren dos matrices de enteros sin signo. 
En el primer caso los recursos utilizados son similares. Por lo que la selecciÃ³n de 
uno u otro procesador depende de la semÃ¡ntica a utilizar. Mientras que, en el 
segundo caso los recursos utilizados por las TdPN son mayores. La ventaja de una 
con respecto a la otra en cuestiÃ³n de recursos estÃ¡ determinada por incremento de 
la matriz de incidencia dada por la conversiÃ³n de las transiciones Time a su 
equivalente no interrumpibles. 
4. El procesador que implementa la semÃ¡ntica TdPN utiliza dos estados para realizar 
el cÃ¡lculo de los toquen que entran de una transiciÃ³n y los que salen de esta. Esta 
diferenciaciÃ³n de estados nos permite insertar una nueva red de Petri entre los dos 
estados de una transiciÃ³n, lo que posibilita que el procesador puede ser extendido a 
redes de Petri jerÃ¡rquicas; ya sea haciendo uso de la semÃ¡ntica TdPN o de las redes 
de Petri ordinarias. Esto en la actualidad es motivo de una nueva investigaciÃ³n. 
Las dos semÃ¡nticas son investigadas, puesto que las TPN requieren de menos 
recursos para resolver problemas no interrumpibles (que son los mÃ¡s habituales). 
Mientras que las TdPN presentan potencial de mejora al permitir construir redes de 
Petri jerÃ¡rquicas. [8]. 
5 AnÃ¡lisis de Rendimiento 
La implementaciÃ³n de sistema ha sido realizada en una plataforma Atlysâ„¢ Spartan6, los cores utilizados son los MicroBlaze ver8.40 [9] que ejecuta un Sistema Operativo 
XilKernel ver5.01a. Interconectado con el Procesador de Petri Temporizado por un bus 
AXI [10]. 
Para comprobar correcto funcionamiento del IP Core y analizar los tiempos de 
sincronizaciÃ³n, se realizaron mediciones para distinto nÃºmero de iteraciones y numero 
1103
de hilos tratando de acceder a una variable compartida en exclusiÃ³n mutua. Luego se 
compararon el Procesador de Petri con una implementaciÃ³n utilizando semÃ¡foros, 
ambos resolviendo un mismo problema. La elecciÃ³n de este segundo mÃ©todo de 
sincronizaciÃ³n se basa en que son el mecanismo mÃ¡s ligero para realizar Ã©stas tareas. 
A partir de estas mediciones se calculÃ³ el Speedup, los resultados se muestran en la 
Fig. 2, se puede observar que, para todos los casos, el procesador de Petri es en 
promedio es entre un 15% y un 30% mÃ¡s rÃ¡pido que el uso de semÃ¡foros para resolver 
el problema de sincronizar mÃºltiples hilos que desean escribir sobre una variable 
compartida e incluso, se alcanzan picos de hasta un 70%. 
 
Fig. 2. Tiempos de sincronizaciÃ³n por iteraciÃ³n 
Estas mediciones se realizaron con tiempos ğ¸ğ¹ğ‘‡ ğ‘¦ ğ¿ğ¹ğ‘‡ cero, de manera que el 
rendimiento es el mismo obtenido en el procesador de Redes de Petri sin la semÃ¡ntica 
temporal. Esto es vÃ¡lido ya que el tiempo de una transiciÃ³n es parte del modelo, es 
decir, es el mismo para el procesador de Petri como para la implementaciÃ³n con 
semÃ¡foros y el propÃ³sito es medir Ãºnicamente los tiempos de sincronizaciÃ³n. 
AdemÃ¡s, como se observa en la Fig. 3, el procesador necesita Ãºnicamente un semiciclo de reloj, desde que el contador alcanza el valor EFT hasta que el disparo se coloca 
en la cola de salida. La demora introducida es despreciable en relaciÃ³n con el tiempo 
que tiene un Î´t de un ciclo de reloj. 
Teniendo en cuenta lo despreciable de la latencia y tomando el tiempo como parte 
del modelo es posible analizar el rendimiento sin tener en cuenta los vectores EFT y 
LFT. 
 
Fig. 3. EjecuciÃ³n en hardware. 
1,35
1,73 1,74
1,10
1,24 1,241,16
1,26 1,26
0,0
0,5
1,0
1,5
2,0
10 1000 10000
Sp
ee
d
 u
p
2 Escritores
4 Escritores
5 Escritores
1104
6 Crecimiento del IP Core 
Se analizÃ³ el crecimiento del procesador en funciÃ³n de los parÃ¡metros que posee. 
Para esto se generaron procesadores de 8x8, 16x16, 32x32, 48x48 y 64x64 (Plazas por 
TransiciÃ³n) con capacidad de 7 bits por plaza y elementos de tiempo de 48 bits y se 
graficaron los resultados, los que se pueden observar en la Fig. 4. 
Se observa que el crecimiento del IP Core no es algo para despreciar, puesto que la 
cantidad de elementos empleados crese rÃ¡pidamente con el producto de las Plazas por 
las Transiciones. 
Fig. 4. Crecimiento del IP Core 
 
Por otra parte, ya que es posible sintetizar un procesador para cada semÃ¡ntica es 
deseable determinar y comparar el consumo de recursos para cada uno. La Fig. 5 
muestra la comparaciÃ³n del crecimiento entre las distintas implementaciones. 
Se puede observar que ambos procesadores utilizan aproximadamente la misma 
cantidad de Flip-Flops pero la implementaciÃ³n para redes temporizadas utiliza un 90% 
mas LUTs para el mismo nÃºmero de plazas y transiciones. 
 
Fig. 5. Recursos usados por distintas semÃ¡nticas. 
1105
7 ConclusiÃ³n y Aportes 
En el presente trabajo, se desarrolla el Procesador de Petri con Tiempo, que permite 
desacoplar los la concurrencia del procesamiento secuencial. Teniendo en cuanta que 
el Procesador de Petri con Tiempo permite utilizar Redes de Petri Temporizadas, este 
procesador puede remplazar a su predecesor y preserva sus particularidades. 
El modelo de Petri es adecuado para implementar, validar y verificar un sistema 
paralelo con concurrencia, este tiene una representaciÃ³n algebraica que este procesador 
usa como el cÃ³digo ejecutable. Las ventajas de este procesador son la disminuciÃ³n de: 
ï‚· Esfuerzo de programaciÃ³n, la ecuaciÃ³n de estado es ejecutada directamente en el 
procesador, y no se requiere programaciÃ³n adicional. 
ï‚· El gap entre las restricciones temporales y sus programaciones. Puesto que se trata 
de los vectores temporales propios de la semÃ¡ntica usada por el procesador. 
