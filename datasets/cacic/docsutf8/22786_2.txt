Hacia la prueba de correcci√≥n de clases
Ôªø
La actividad de desarrollar programas orientados a objetos, los cuales involucran referencias a memoria, pueden introducir errores dif√≠ciles de identificar con el uso de un razonamiento operacional. Esto da
lugar a la necesidad de contar con un marco te√≥rico para la prueba de correcci√≥n de clases.
A partir de esta motivaci√≥n y basandonos en la idea propuesta por B. Meyer en [Meyer 03a], trabajamos
en el desarrollo de una sem√°ntica formal para probar, matem√°ticamente, que clases equipadas con contratos
satisfacen los mismos.
Keywords: M√©todos Formales, Orientaci√≥n a Objetos, Prueba de Correcci√≥n, Contratos, Funciones de
Abstracci√≥n.
Abstract
The activity of object oriented program development, which may involve references variables, is prone
to errors which are hard to find by operational reasoning. Hence the need for a theoretical framework for
proving class correctness.
Given this motivation and based on ideas proposed by B. Meyer in [Meyer 03a] we develop a formal
semantics for mathematically proving that contract equipped classes satisfy their specifications.
Keywords: Formal Methods, Object Orientation, Correctness Proofs, Contracts, Abstraction Functions.
1. Introducci√≥n
Tal como se lo muestra en varios trabajos ([EWD 1036], [EWD 76]), el razonamiento operacional
sobre programas es una actividad no s√≥lo mentalmente desgastante, sino tambi√©n proclive a la introducci√≥n de errores. Si adem√°s se consideran aquellos programas que involucran variables conteniendo
referencias a memoria, la situaci√≥n es a√∫n peor ya que aparecen casos de aliasing. Para ilustrar sobre
1717
los problemas que acaecen cuando se trabaja con referencias a memoria, damos a continuaci√≥n un
ejemplo.
Supongamos que se define una clase A de la siguiente manera:
class A
feature{NONE}
f:A
g:A
feature{A}
get f is
do
Result := f
end
Supongamos adem√°s que tenemos dentro de A un m√©todo cuya implementaci√≥n se compone de las
siguientes sentencias:
S; f := g; a := f.get f
donde f y g son los atributos que arriba declaramos.
Ahora, dada esta otra secuencia de instrucciones ( siendo S, f y g los mismos que en la implementaci√≥n anterior ):
S; a := g.get f
Se plantea el interrogante si en ambas implementaciones el valor de a al finalizar la ejecuci√≥n de
las sentencias respectivas ser√° el mismo.
En este punto quiz√° el lector este receloso de responder afirmativamente. Tal vez resulte m√°s
interesante preguntar por que la proposici√≥n anterior no es verdadera para el caso general. Con las
herramientas desarrolladas en este trabajo se puede dar una respuesta (formal) a este interrogante.
La necesidad de una sem√°ntica para la prueba de correcci√≥n de programas se pone de manifiesto
adem√°s cuando queremos probar que clases equipadas con contratos satisfacen los mismos. Pero esto
no es posible si no se cuenta con un marco te√≥rico adecuado.
Consideremos por ejemplo el m√©todo make de la clase LIST SET la cual implementa el √°lgebra de los conjuntos usando listas, y make crea un objeto representando el conjunto vac√≠o. Ahora
preguntemonos cual es la postcondici√≥n de este m√©todo. Con los constructores sint√°cticos de Eiffel
(o de cualquier otro lenguaje de programaci√≥n imperativo) no es posible formalizarla, es necesario
contar con un mayor poder expresivo en los contratos. Tal requerimiento es satisfecho en este trabajo, pero todav√≠a esto no es suficiente. Suponiendo que en las aserciones se permite la utilizaci√≥n de
funciones matem√°ticas abstractas y que tenemos un atributo Ds: LIST[G] el cual esta destinado
a contener los elementos del conjunto, es probable que se quiera expresar la postcondici√≥n de make
del siguiente modo: Ds = ‚àÖ .
Sin embargo la expresi√≥n anterior sufre dos inconvenientes. El mas leve es que es dependiente
1718
de la implementaci√≥n, un conjunto podr√≠a quiz√° estar representado mediante un atributo con diferente
nombre, o peor a√∫n podr√° representarse simult√°neamente usando un √°rbol y una pila, por ejemplo, por
lo que mas all√° del nombre la postcondici√≥n anterior no nos sirve. Entonces resulta un tanto contradictorio pensar en dos post condiciones diferentes para dos m√©todos cuyo comportamiento esperado
es exactamente el mismo. Pero mas grave a√∫n, la expresi√≥n anterior se encuentra incorrectamente
tipada, estamos igualando un objeto del tipo LIST con un conjunto.
Es importante tener clases probadas, en especial aquellas que implementan √°lgebras como enteros,
√°rboles, grafos, etc, porque son utilizadas exhaustivamentes por el programador de aplicaci√≥n, quien
construye su software bas√°ndose en estas.
Uno puede optar por omitir estas pruebas de correcci√≥n, pero trayendo consigo el riesgo de errores
graves para la consistencia de los programas. El lector puede intentar analizar el siguiente m√©todo
(implementado en el lenguaje Eiffel) que invierte el orden de los elementos de una lista e intentar
determinar si el mismo cumple su prop√≥sito1:
reverse is
-- Change the list to have the same elements in reverse order
localprevious, next: NODE[G]
do
from
next := first
until
next = Void
loop
previous := first
first := next
next := next.right
first.put right(previous)
end
El lector perceptivo, habr√° notado que el error es dif√≠cil de encontrar. Pero lo que es m√°s grave
a√∫n, es que el cliente del m√©todo asume (como es de esperar) que el mismo est√° correctamente implementado, mientras que para el caso considerado el simple hecho de invocar a reverse y luego
recorrer la lista dejar√° a su programa en un loop infinito. Es importante notar que errores como estos
pueden encontrarse en varios programas en uso.
El esfuerzo que requiere la correccion matem√°tica de componentes de software es justificado por
el amplio reuso que los mismos poseen. Y si tales piezas de software han de ser usadas en sistemas
cr√≠ticos, esta justificaci√≥n se hace necesidad.
En el presente trabajo, se introducen las nociones b√°sicas del formalismo con el objetivo de exponer luego la sem√°ntica definida. Adem√°s, se presenta la noci√≥n de modelo asociado a una clase con el
prop√≥sito de servir como funci√≥n de abstracci√≥n de forma tal de especificar los contratos de una clase,
resolviendo los inconvenientes que presentamos anteriormente. El trabajo concluye con un ejemplo
1la clase NODE contiene un campo right que mantiene una referencia al pr√≥ximo elemento de la lista. El m√©todo
put right(x) actualiza dicho campo con el valor referenciado por x
1719
pr√°ctico, donde se hace uso del formalismo desarrollado para establecer la correcci√≥n de un m√©todo.
2. El formalismo b√°sico
En esta secci√≥n se definen algunos de los conceptos utilizados en el presente art√≠culo. Los mismos
se introducen en [Meyer 03a] y se encuentran definidos con mas detalles en [Blanco 05], en donde
adem√°s se corrigen algunos errores del trabajo original.
Habiendo introducido estos conceptos, se describir√° la sem√°ntica formal asociada a un subconjunto del lenguaje de programaci√≥n Eiffel.
2.1. Nociones preliminares
Las abstracciones aqu√≠ presentadas sirven de base para la definici√≥n de la sem√°ntica sobre la
cual se realizan las pruebas matem√°ticas de correcci√≥n de clases equipadas con contratos al estilo
Eiffel.
A continuaci√≥n se brinda una definici√≥n de cada uno, y cual es su significado en este contexto de
prueba.
Address: Denota el conjunto de todas las posibles direcciones abstractas de memoria.
Objects: Denota el conjunto de todas las direcciones que pueden albergar objetos. Cabe destacar que
Objects ‚äÜ Address.
Expanded: Denota el conjunto de todos los valores que no son referencias; por ejemplo los enteros, los
booleanos, etc.
Values: Denota el conjunto de todos los posibles valores de un sistema; es decir Values .= Objects ‚à™
Expanded.
States: Denota el conjunto de todos los posibles estados de un sistema. Un elemento s ‚àà States se
define como una tupla cuyo primer componente es un conjunto de funciones (Objects 7‚Üí Objects) que
modela las variables involucradas en el sistema; y la segunda componente es un conjunto que contiene
los objetos presentes en ese estado.
As√≠ en este sistema formal una variable representara una funci√≥n con alguno de los siguientes
perfiles:
Objects 7‚Üí States 7‚Üí Objects, para aquellas que constituyan una referencia a otros objetos.
Objects 7‚Üí States 7‚Üí Expanded, para aquellas las cuales contengan un valor subclase de EXPANDED,
como por ejemplo las del tipo INTEGER. Donde Expanded es el conjunto formado por la uni√≥n disjunta
de los conjuntos matem√°ticos B, R, etc.
√âste enfoque expresa el hecho de que el objeto el cu√°l una variable f referencia o el valor que √©sta
contiene (en el caso que f sea de tipo EXPANDED) en una instancia de la ejecuci√≥n de un programa
Eiffel, varia seg√∫n el estado y el objeto en donde el identificador f se halle.
1720
2.1.1. Interpretando cambios de estados
Un programa orientado a objetos consiste de una secuencia de cambios de estados que reflejan la
ejecuci√≥n de determinados constructores.
As√≠ la invocaci√≥n a un procedimiento r(a) del objeto x (x.r(a)), el cual produce un cambio de
estado en nuestro sistema, podremos modelarlo como una funci√≥n de la forma A 7‚Üí States 7‚Üí States
donde A denotan los par√°metros del procedimiento y la funci√≥n States 7‚Üí States describe el nuevo
estado producido por la ejecuci√≥n del procedimiento en t√©rminos del estado previo.
De esta manera los posibles cambios de estados, dado que un estado est√° definido como un conjunto de objetos y una colecci√≥n de funciones sobre esos objetos, son
1. Cambiar una de las funciones en el primer componente del estado; al nivel mas b√°sico esto significa
cambiar el valor de una de las funciones en uno de sus posibles argumentos.
2. Cambiar el conjunto de objetos presente en la segunda componente del estado. 2
2.2. Sem√°ntica de los operadores b√°sicos
A continuaci√≥n presentamos la sem√°ntica formal de un subconjunto del lenguaje Eiffel. Esto
permite ‚Äúmapear‚Äù programas a funciones matem√°ticas que los modelan. De esta forma se define una
sem√°ntica funcional de un lenguaje imperativo, permitiendo de esta manera introducir la noci√≥n de
funci√≥n de abstracci√≥n en este ultimo paradigma, como veremos mas adelante.
2.2.1. El operador de asignaci√≥n
La operaci√≥n fundamental en el paradigma imperativo, transversal al orientado a objetos, es la
asignaci√≥n. En nuestro modelo, la asignaci√≥n, como transformador de estados b√°sico, estar√° representada por una funci√≥n denominada ‚Äúsustituci√≥n de funciones‚Äù y denotada como ‚Äú:=‚Äù, cuyo perfil
es (Objects 7‚Üí States 7‚Üí Objects) 7‚Üí (Objects 7‚Üí States 7‚Üí V alues) 7‚Üí Objects 7‚Üí States 7‚Üí
States. As√≠, se permite una sustituci√≥n de la forma
f := E
De esta manera definimos la sem√°ntica del operador de asignaci√≥n de Eiffel, mediante la funci√≥n
:=, del siguiente modo 3
Regla 1 (asignacion)
f := g
.
= [f := g]
El operador de substituci√≥n de funciones, intuitivamente, dado un objeto o y un estado s, retorna
un estado s‚Ä≤ en donde solo cambia f para un √∫nico elemento de su dominio como se muestra en la fig.
1.
Para nuestro trabajo utilizaremos las siguientes propiedades b√°sicas de este operador, cuya demostraci√≥n puede ser encontrada en [Blanco 05] junto con una definici√≥n formal de :=.
2Notar que esto no implica que se modifique el conjunto Objects definido anteriormente.
3En adelante para denotar la sem√°ntica asociada a un constructor del lenguaje c, utilizaremos la notaci√≥n c, y se
utilizar√°n adem√°s los corchetes para agrupar funciones
1721
f √ó //
f :=g
%%J
J
J
J
J
J
J
J
J
J
J
J
J Si f 6= g
g //
Figura 1: Ilustraci√≥n de la Asignaci√≥n
Propiedad 1
f o ([f := g] o s) = g o s
Propiedad 2
o 6= o‚Ä≤ ‚à® f 6= h‚áí h o ([f := g] o‚Ä≤ s) = h o s
2.2.2. Secuenciamiento de instrucciones
La sem√°ntica para el secuenciamiento de instrucciones hace uso de un nuevo operador de composici√≥n de funciones, denominado rightmost composition (se denota ), y se define como4
Definici√≥n 1 (rgmc)
 :: (A 7‚Üí B 7‚Üí C) 7‚Üí (A 7‚Üí C 7‚Üí D) 7‚Üí A 7‚Üí B 7‚Üí D
[f  g] a b
.
= [[f a] [g a]] b
Dado que las instrucciones son abstra√≠das en funciones, el modelo para el secuenciamiento de las
mismas, es la composici√≥n de sus modelos. De esta manera se define su sem√°ntica como
Regla 2 (secuenciamiento)
i; j
.
= [i  j]
Es importante notar que tanto el perfil de i como el de j es de la forma Objects 7‚Üí States 7‚Üí
States, dado que los mismos son transformadores de estados.
2.2.3. Comandos condicionales
Se define la sem√°ntica de los comandos condicionales de manera tradicional utilizando expresiones condicionales del lenguaje funcional
Regla 3 (if)
if b then i else j end .= if b then i else j
La expresi√≥n condicional if se encuentra adem√°s definida de la siguiente manera
Definici√≥n 2 (if)
[if b then i else j end] o s .= if b o s then i o s else j o s
dado que el perfil de b es de la forma Objects 7‚Üí States 7‚Üí Bool y de i, j de la forma Objects 7‚Üí
States 7‚Üí States
4El operador  denota la composici√≥n de funciones usual
1722
2.2.4. Comandos iterativos
La sem√°ntica de los comandos iterativos, se define recursivamente de la siguiente manera
Regla 4 (loop) .
from i until b loop j end .= i  [until b loop j end]
Regla 5 (until) .
until b loop j end .= until b loop j
Definici√≥n 3 (until) . Definimos a until como
[until b loop j] o s .= if b o s then s else [j  [until b loop j]] o s
2.2.5. Llamada a rutinas
La sem√°ntica de la llamada a rutinas utiliza una variante de la composici√≥n de funciones usual
(denotada ) y definida como
Definici√≥n 4 ()
 :: (A 7‚Üí B 7‚Üí C) 7‚Üí (C 7‚Üí B 7‚Üí D) 7‚Üí (A 7‚Üí B 7‚Üí D)
[f  g] a b
.
= g ( f a b ) b
Cuando se invoca una rutina f.r(a1, ...,an), donde r tiene par√°metros formales x1,...,
xn, antes que r comience a ser ejecutada, ocurre que estos √∫ltimos son ligados con los par√°metros
efectivos( o actuales ), de modo tal que referencien a los mismos objetos. En el nivel mas b√°sico del
sistema formal, el efecto anterior puede ser modelado en t√©rminos de nuestro operador de sustituci√≥n
de funciones a trav√©s de la siguiente regla
Regla 6 Llamadas a rutinas
Sea r con par√°metros formales x1,..., xn, luego
f.r(h1, ..., hn) = [f  x1 := h1]  ... [f  xn := hn]  f  r(x1, ..., xn)
Luego puede demostrarse la siguiente propiedad
Propiedad 3
f  set g(h)  f  g
‚àó
= h
3. El modelo asociado a una clase
Si queremos especificar que una clase satisface su contrato, el primer paso es la elecci√≥n de un
modelo asociado la misma.
Dado que estas clases (en particular las mas b√°sicas) est√°n destinadas a modelar √°lgebras abstractas, sus m√©todos deber√°n implementar las funciones de esta ultima, y sus instancias (objetos) se
corresponder√°n con elementos pertenecientes al tipo de inter√©s del √°lgebra abstracta.
1723
A m //
L M

B
L M

LAM
¬µ
// LBM
Figura 2: Correcci√≥n del m√©todo concreto en base a su especificaci√≥n abstracta
Ahora, al momento de la verificaci√≥n de un m√©todo m que implementa una funci√≥n abstracta ¬µ,
deberemos probar que la aplicaci√≥n de m sobre un objeto o, tiene el mismo efecto que la aplicaci√≥n
de ¬µ sobre el elemento del tipo de inter√©s que o representa. Es decir, debemos ver que el diagrama de
la figura 2 conmuta
Pero entonces se plantea el interrogante de como es posible obtener este √∫ltimo a partir del objeto
o. Surge entonces el concepto de modelo.
El modelo asociado a una clase lo representamos a trav√©s del atributo model, el cual es una funci√≥n
que tiene como rango el tipo de inter√©s del √°lgebra abstracta que la clase particular representa, y cuyo
prop√≥sito es definir la funci√≥n de abstracci√≥n para cada una de sus instancias, es decir, aquella funci√≥n
que nos posibilitar√° obtener el elemento que estos representan.
As√≠, model aparece como un atributo m√°s de la clase, con el prop√≥sito de especificar los contratos
de la misma y probar su correcci√≥n. Su definici√≥n estar√° dada, de acuerdo al formalismo que hemos
presentado, en un lenguaje funcional.
Notar que la sem√°ntica de model nos arrojar√° una funci√≥n que tiene como rango un tipo abstracto, que no forma parte del sistema de tipos de Eiffel. Sin embargo, a nivel de implementaci√≥n no
habr√° problemas puesto que model ser√° usado solo para las aserciones (no apareciendo expl√≠citamente en el cuerpo del programa), y por contrapartida este enfoque nos permitir√° escribir post condiciones
concisas y expresivas.
De este modo, se tienen ahora herramientas para definir las funciones de abstracci√≥n sobre objetos.
Para ilustrar sobre la forma en la cu√°l se puede especificar el modelo asociado a una clase damos a
continuaci√≥n dos ejemplos.
Primero definimos a model para la clase NODE[G], la cu√°l va a representar una secuencia cuyos
elementos ser√°n las abstracciones de los objetos contenidos en el atributo item de cada uno de los
objetos del tipo NODE[G] que se hallen conectados entre si v√≠a su otro atributo next.
Declaramos a NODE de la siguiente manera:
class NODE[G]
...
feature{NONE}
item: G
next: NODE[G]
...
feature{SPECIFICATION}
model :: Objects 7‚Üí States 7‚Üí [LGM]
1724
model = abst id
abst:: Objects‚Üí Objects 7‚Üí States 7‚Üí [LGM]
abst f o s =
if f o s = ‚ä•
then [ ]
else [Lf  itemM
‚àó
: Lf  nextM] o s
...
Aqu√≠, id denota la funci√≥n identidad, ‚àó: es el constructor de listas5 que dado un elemento x y una
lista xs retorna una lista cuyo primer elemento es x y el resto de la lista es xs. Mientras que, para
referirnos al rango de la funci√≥n model definida para una clase A, usaremos la notaci√≥n LAM. As√≠ por
ejemplo LINTEGERM = Z, al estilo de la sem√°ntica denotacional cl√°sica.
A su vez, el operador L M se sobrecarga para denotar la funci√≥n de abstracci√≥n sobre objetos, la
cual se define formalmente como:
Definici√≥n 5
L M :: (Objects‚Üí States‚Üí Objects)‚Üí Objects‚Üí States‚Üí A
LfM = f  model
En la definici√≥n anterior cabe la posibilidad que la lista sea infinita, en el caso de que un ciclo exista
entre los objetos de la clase NODE. La prohibici√≥n de esta condici√≥n podr√≠a constituir el invariante de
clase de LINKED LIST, la cu√°l puede implementarse utilizando objetos de tipo NODE.
4. Un caso de estudio
Mostramos en esta secci√≥n un ejemplo de la aplicaci√≥n de todas las herramientas te√≥ricas expuestas en el presente trabajo, donde se pondr√°n de manifiesto todas las carencias existentes a la hora de
establecer la correcci√≥n de clases en ausencia del formalismo aqu√≠ presentado, las cu√°les son enumeradas en la conclusi√≥n. En adici√≥n veremos de que manera las post condiciones de los m√©todos son
de gran ayuda a la hora de modularizar las pruebas.
Dado el siguiente m√©todo de la clase LINKED LIST implementado en Eiffel y anotado con
aserciones, probaremos que el cuerpo del ciclo mantiene el invariante6.
in( x: G ): BOOLEAN is
do
from
g := f; b := false
invariant I1
‚àó
‚àß I2
variant
‚àó
# LgM
until ( b or g = Void ) loop
b := ( x.is equal( g.get item ) ); g := g.get next
5Hay en realidad una sutil diferencia sobre la cual no conviene ahondar en el presente trabajo. Sin embargo esta
omisi√≥n no presentara mayores obst√°culos
6Para evitar extendernos demasiado en el trabajo, no se expone la prueba de correcci√≥n total
1725
end
Result := b
ensure Result
‚àó
‚â° LxM
‚àó
in LfM
end
donde
I1 : b
‚àó
‚â° LxM
‚àó
in (LfM
‚àó
‚Üë (
‚àó
# LfM
‚àó
‚àí
‚àó
# LgM))
I2 : LfM = (LfM
‚àó
‚Üë (
‚àó
# LfM
‚àó
‚àí
‚àó
# LgM))
‚àó
‚àí‚Äñ LgM
Antes de comenzar con la prueba hacemos las siguientes aclaraciones con respecto a la notaci√≥n y
funciones usadas:
Las funciones l√≥gico-matem√°ticas que tienen un asterisco arriba pueden considerarse como las usuales. Si bien no son las mismas funciones, tienen id√©ntica sem√°ntica, difiriendo solo en los tipos de sus
argumentos iniciales7.
x
‚àó
in xs y retorna verdadero si y solo si el elemento se halla contenido en xs.
La funci√≥n
‚àó
# retorna el numero de elementos contenidos en una lista.
xs
‚àó
‚Üë n retorna una secuencia con los primeros n elementos de xs; y xs ‚àó. n retorna el n-√©simo elemento
de la secuencia xs 8.
‚àó
‚àí‚Äñ , es el operador de concatenaci√≥n de secuencias.
As√≠, debemos demostrar, siendo Body el cuerpo del ciclo
(I1
‚àó
‚àß I2)
‚àó
‚àß
‚àó
¬¨ B
‚àó
‚áí Body  I1 (1)
El uso de funciones de abstracci√≥n, nos permite hablar de propiedades asociadas a las implementaciones. As√≠, de acuerdo a las post condiciones de los m√©todos usados en la implementaci√≥n de la
funci√≥n in, es posible inferir (prueba omitida) las siguientes propiedades9 que nos servir√°n en la
prueba de correcci√≥n
1. g.get next ‚àó= LgM
‚àó
‚Üì
‚àó
1
2. g.get item ‚àó=
‚àó
hd LgM
3. x.is equal(y) ‚àó‚â° LxM ‚àó= LgM
7A los efectos de brevedad no definimos el operador ‚àó. Sin embargo esto no dificultara la comprensi√≥n de los temas
aqu√≠ tratados
8Es claro que estas funciones son parciales, no est√°n definidas en caso que la secuencia posea menos de n elementos
9Estas, nos permiten comprender la funci√≥n que realizan estos m√©todos de una manera simple, sin necesidad de revisar
el c√≥digo para esto
1726
Demostremos la propiedad 1 enunciada anteriormente
Sea [b := ( x.is equal( g.get item ) )][g := g.get next] I1
‚â° { hipotesis }
[b := LxM ‚àó= L
‚àó
hd LgMM][g := LgM
‚àó
‚Üì
‚àó
1] I1
‚â° { def. I1; prop. LLxMM ‚àó= LxM }
[b := LxM ‚àó=
‚àó
hd LgM][g := LgM
‚àó
‚Üì
‚àó
1]
 b
‚àó
‚â° LxM
‚àó
in (LfM
‚àó
‚Üë (
‚àó
# LfM
‚àó
‚àí
‚àó
# LgM))
‚â° { prop. Q(x‚Üê E) ‚àó= [x := E]Q }
LxM ‚àó=
‚àó
hd LgM
‚àó
‚â° LxM
‚àó
in (LfM
‚àó
‚Üë (
‚àó
# LfM
‚àó
‚àí
‚àó
# LLgM
‚àó
‚Üì
‚àó
1M))
‚â° { prop. LLxMM ‚àó= LxM }
LxM ‚àó=
‚àó
hd LgM
‚àó
‚â° LxM
‚àó
in (LfM
‚àó
‚Üë (
‚àó
# LfM
‚àó
‚àí
‚àó
# LgM
‚àó
‚Üì
‚àó
1))
‚â° { prop. #Xs ‚Üì 1 = #Xs‚àí 1; algebra }
LxM ‚àó=
‚àó
hd LgM
‚àó
‚â° LxM
‚àó
in (LfM
‚àó
‚Üë (
‚àó
# LfM
‚àó
‚àí
‚àó
# LgM
‚àó
‚Üì
‚àó
1 +1))
‚â° { prop. Xs ‚Üë (n + 1) = (Xs ‚Üë n) ‚àí‚Äñ (Xs.n); hipotesis (g
‚àó
6= V oid) }
LxM ‚àó=
‚àó
hd LgM
‚àó
‚â° LxM
‚àó
in (LfM
‚àó
‚Üë (
‚àó
# LfM
‚àó
‚àí
‚àó
# LgM)
‚àó
‚àí‚Äñ LfM ‚àó. (
‚àó
# LfM
‚àó
‚àí
‚àó
# LgM))
‚â° { prop. in }
LxM ‚àó=
‚àó
hd LgM
‚àó
‚â° LxM
‚àó
in (LfM
‚àó
‚Üë (
‚àó
# LfM
‚àó
‚àí
‚àó
# LgM))
‚àó
‚à® LxM
‚àó
in (LfM ‚àó. (
‚àó
# LfM
‚àó
‚àí
‚àó
# LgM))
‚â° { hipotesis; logica }
LxM ‚àó=
‚àó
hd LgM
‚àó
‚â° LxM
‚àó
in ([LfM ‚àó. (
‚àó
# LfM
‚àó
‚àí
‚àó
# LgM)]
‚â° { prop. As ‚àí‚Äñ Bs.(#As) = hd Bs }
LxM ‚àó=
‚àó
hd LgM
‚àó
‚â° LxM
‚àó
in ([LfM ‚àó. (
‚àó
# LfM
‚àó
‚àí
‚àó
# LgM)]
‚â° { def. in }
LxM ‚àó=
‚àó
hd LgM
‚àó
‚â° LxM ‚àó=
‚àó
hd LgM
QED
As√≠ demostramos la implicaci√≥n planteada en 1.
5. Conclusi√≥n
La sem√°ntica aqu√≠ introducida ha permitido detectar casos de aliasing como el del ejemplo expuesto en la introducci√≥n, satisfaciendo as√≠ un agudo requerimiento que aparece al razonar con programas
que contienen referencias a memoria. Si bien a√∫n se est√°n sentando las bases de este marco de trabajo
matem√°tico, los resultados que se consiguieron hasta aqu√≠ nos hace mirar el futuro con optimismo.
Una de las carencias a la hora de especificar e implementar tipos abstractos de datos en lenguajes
imperativos es que no se dispone de una sem√°ntica apropiada para la introducci√≥n de funciones de
abstracci√≥n. Por ello uno de los logros de esta sem√°ntica es permitir trabajar con este tipo de funciones
dentro del paradigma imperativo.
1727
Como se puede apreciar en el caso de estudio, si no cont√°ramos con las herramientas te√≥ricas
que presentamos, no se podr√≠a demostrar, mediante formalismos como la l√≥gica de Hoare, que el
m√©todo implementa correctamente la operaci√≥n del √°lgebra de las secuencias. Principalmente porque
no tendr√≠amos forma de ir de clases concretas a √°lgebras abstractas.
La funci√≥n de abstracci√≥n asociada a cada clase permite expresar los contratos de una manera m√°s
simple y completa, evitando as√≠ subespeficaciones o sobre especificaciones. Por lo que a diferencia
de lo que se establece en [Meyer 03b], los contratos de las clases de librer√≠as como Eiffel Base
no deber√≠an ser extendidos, sino que deber√≠an ser reformulados.
Es importante se√±alar la utilizaci√≥n de las post condiciones de los m√©todos utilizados en la prueba
de correcci√≥n del ejemplo que aqu√≠ presentamos, lo que permite modularizar las demostraciones,
simplificando las mismas.
5.1. Trabajos futuros
El primer paso hacia la prueba de correcci√≥n de clases es extender la la sem√°ntica hasta ahora
definida al resto de los constructores del lenguaje Eiffel.
Luego, es menester incorporar la sem√°ntica dentro de alg√∫n demostrador de teoremas de manera
de generar autom√°ticamente las obligaciones de prueba.
Por otro lado es nuestra meta extender el proceso realizado en el presente trabajo a una amplia
variedad de estructuras b√°sicas y algoritmos fundamentales. Esto involucra construir y desarrollar las
teor√≠as asociadas a estas clases, extender los contratos de las mismas, realizar las pruebas y refinar las
mismas en el proceso.
Todos estos trabajos futuros conforman una linea importante de investigaci√≥n, que se inserta dentro del creciente inter√©s de la comunidad de orientaci√≥n a objetos en los m√©todos formales.
