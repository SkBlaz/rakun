Desarrollo de un visualizador de se√±ales de radar
Ôªø
El presente trabajo consiste en el desarrollo de un sistema de visualizaci√≥n de informaci√≥n para 
interfaces de sistemas de radar. El mismo es un sistema de software flexible y portable, que permite 
ser empleado en radares de diferentes tecnolog√≠as y capaz de adaptarse eficientemente a las 
necesidades espec√≠ficas de cada dominio de aplicaci√≥n.  
El sistema permite tambi√©n implementar algoritmos de procesamiento de informaci√≥n y 
reconocimiento autom√°tico de objetivos. 
 
Palabras clave: Radar, Visualizaci√≥n de Informaci√≥n, Procesamiento de Se√±ales. 
53
1 INTRODUCCI√ìN 
Conceptualmente, un sistema de radar consta de cinco componentes: un generador, un receptor, un 
amplificador, un analizador o procesador y un visualizador [1]. En el presente trabajo se describe el 
desarrollo de un sistema de software cuyo objetivo es reemplazar los √∫ltimos dos componentes; de 
forma tal de poder actualizar y modernizar las prestaciones actuales de diferentes radares, como por 
ejemplo: radares de control de tr√°fico a√©reo, radares t√°cticos de uso militar o civil, radares de 
buques, entre otros. 
Las funciones del analizador de un sistema de radar consisten en obtener de las se√±ales recibidas la 
informaci√≥n deseada, determinando si las reflexiones obtenidas por la antena se corresponden con 
objetos de inter√©s para el sistema. Los componentes de an√°lisis de los sistemas modernos llevan a 
cabo una gran variedad de funciones que permiten sintetizar la informaci√≥n deseada de manera 
simple y eficiente; como ser eliminaci√≥n de ruido, predicci√≥n de trayectorias de objetivos, 
identificaci√≥n de objetos y dem√°s. 
 
 
 
 
 
 
 Figura 1-A: Presentaci√≥n 
Plan Position Indicator 
 Figura 1-B: Presentaci√≥n 
Tipo ‚ÄúB‚Äù 
 
 
El visualizador de un radar tiene por objetivo presentar en una pantalla o display la informaci√≥n 
procesada por el analizador. Esta presentaci√≥n puede realizarse de diferentes formas, seg√∫n sean las 
necesidades del sistema. Por ejemplo, los radares de b√∫squeda o vigilancia que efect√∫an coberturas 
de 360¬∫ suelen utilizar presentaciones de tipo Plan Position Indicador (PPI) (V√©ase Figura 1-A), las 
cuales muestran los objetivos en forma polar centrado en la posici√≥n del radar; los radares t√°cticos 
de funcionamiento Aire-Aire, en cambio, suelen utilizar presentaciones de tipo ‚ÄúBote‚Äù o ‚ÄúB‚Äù (V√©ase 
Figura 1-B), las cuales ubican en el display los distintos objetivos seg√∫n  la informaci√≥n de 
distancia (l√≠nea vertical) y azimuth (l√≠nea horizontal). [1] 
En las secciones subsiguientes se describe detalladamente el trabajo de dise√±o y desarrollo de un 
sistema de visualizaci√≥n para se√±ales de radares. Posteriormente, se detalla el trabajo de 
implementaci√≥n del sistema, a modo de caso de estudio, adaptado a una plataforma tecnol√≥gica 
espec√≠fica. 
2 DISE√ëO ARQUITECT√ìNICO 
El dise√±o arquitect√≥nico del sistema fue desarrollado en base a un an√°lisis detallado de las 
caracter√≠sticas funcionales y no funcionales requeridas.  
2.1 Caracter√≠sticas Funcionales del Sistema 
El sistema debe poder procesar se√±ales provenientes de distintos dispositivos, as√≠ como tambi√©n de 
otros componentes de software. Las se√±ales a procesar por el sistema pueden ser clasificadas en los 
siguientes tipos: 
‚Ä¢ Se√±ales anal√≥gicas y/o digitales provenientes del radar. 
54
‚Ä¢ Se√±ales anal√≥gicas y/o digitales provenientes de dispositivos de hardware externos al radar.  
‚Ä¢ Se√±ales digitales provenientes de componentes de software independientes, que puedan 
comunicarse con el sistema para prop√≥sitos espec√≠ficos. 
‚Ä¢ Se√±ales provenientes de los controles manuales del dispositivo soporte del sistema. 
 
Las se√±ales provenientes del dispositivo de radar son variadas y de caracter√≠sticas diversas. En 
primer lugar, se necesita conocer los valores de las reflexiones obtenidas por la antena del radar. 
Pero adem√°s, estos datos deben procesarse conjuntamente con la posici√≥n de la antena (lo cual 
depende del tipo de radar y de los modos de operaci√≥n que el mismo provea) e informaci√≥n de 
sincronizaci√≥n de tiempos entre env√≠o y recepci√≥n; de modo tal de poder componer una 
representaci√≥n adecuada de la zona explorada por el radar. A esto se suman las se√±ales provenientes 
de funcionalidades espec√≠ficas provistas por el radar; como por ejemplo, las funciones de 
seguimiento (tracking) de objetivos, muy utilizadas en sistemas de radares para tr√°fico a√©reo o 
radares t√°cticos de uso militar. 
Frecuentemente, los sistemas de radar modernos se comunican con otros dispositivos para fines 
espec√≠ficos. En radares meteorol√≥gicos o de tr√°fico a√©reo es muy com√∫n ‚Äìpor ejemplo- 
complementar la informaci√≥n detectada por el radar con informaci√≥n geogr√°fica o im√°genes 
satelitales de la zona explorada. En radares instalados en buques o aviones resulta de vital 
importancia contar con informaci√≥n de navegaci√≥n georeferencial, habitualmente provista por alg√∫n 
dispositivo o sistema externo (GPS, por ejemplo.). Por esto, es importante tener en cuenta al 
momento de dise√±ar y desarrollar un sistema de estas caracter√≠sticas que las se√±ales de entrada 
pueden ser de naturaleza y procedencia sumamente heterog√©neas. 
Finalmente debe considerarse que los radares modernos cuentan con diferentes modos de operaci√≥n, 
en los cuales puede variarse el funcionamiento mismo del dispositivo, alterando ‚Äìpor ejemplo- el 
movimiento de la antena y, por ende, la zona de exploraci√≥n; o simplemente la informaci√≥n 
presentada en el display. Estos cambios en los par√°metros de funcionamiento del sistema deben 
poder ser modificados por el operador del sistema, por medio de controles por ejemplo. 
Como resultado del procesamiento de se√±ales, el sistema debe presentar en un display informaci√≥n 
referente a los objetos detectados por el radar. Si bien la naturaleza de esta informaci√≥n depende del 
dominio de aplicaci√≥n del sistema; es posible generalizar que el sistema debe presentar un conjunto 
de ¬´objetos¬ª y ¬´propiedades¬ª, actualizando los cambios observados en los mismos y seleccionando 
aquellos atributos que puedan ser ignorados o destacados en la presentaci√≥n. 
En lo que respecta a las funcionalidades de interface, el sistema debe proveer una unidad de 
visualizaci√≥n multifunci√≥n (MFD ‚Äì Multi Function Display) que pueda proyectar presentaciones 
gr√°ficas flexibles y f√°cilmente modificables, que se adapten adecuadamente a las necesidades 
operativas de los usuarios. Para esto, resulta esencial poder definir diferentes tipos de 
presentaciones y configurar las caracter√≠sticas de las mismas seg√∫n se desee. 
2.2 Caracter√≠sticas No Funcionales del Sistema 
B√°sicamente, este sistema debe llevar cabo un proceso de adquisici√≥n, interpretaci√≥n y presentaci√≥n 
de informaci√≥n en tiempo real. Para que el mismo pueda ser implementado con √©xito, el dise√±o 
arquitect√≥nico del sistema debe considerar una serie de condiciones que afectar√°n de manera cr√≠tica 
el desempe√±o del sistema. 
En primer lugar, el sistema debe poder cumplir requisitos de performance sumamente estrictos. El 
sistema debe responder a las √≥rdenes del usuario con la mayor celeridad posible y todos los cambios 
detectados en la informaci√≥n a presentar deben actualizarse en el MFD r√°pidamente. De modo tal de 
poder presentar en el display una representaci√≥n correcta y precisa de la zona explorada. 
En segundo t√©rmino; el sistema debe poder ser actualizado con facilidad, en pos de adaptarse a 
diferentes cambios, tanto en lo que respecta al dominio de aplicaci√≥n como a las necesidades de los 
55
usuarios. Principalmente, el sistema debe adaptarse de manera sencilla para procesar se√±ales 
provenientes de nuevos dispositivos de hardware o componentes de software, modificar los 
algoritmos de procesamiento de se√±ales, cambiar o agregar formatos de presentaci√≥n de 
informaci√≥n, entre otras funcionalidades importantes. 
Otro aspecto central a tener en cuenta es la portabilidad del sistema. Es sumamente importante que 
el sistema pueda ser migrado a diferentes plataformas tecnol√≥gicas, adaptando su funcionalidad a 
distintos dominios de aplicaci√≥n.  
Finalmente, resulta importante considerar que el sistema debe ser implementado en una plataforma 
que provea un alto nivel de desempe√±o en la ejecuci√≥n y sincronizaci√≥n de procesos en tiempo real.  
2.3 Arquitectura de Software del Sistema 
Las caracter√≠sticas buscadas en la arquitectura de software a desarrollar deben garantizar una f√°cil 
evoluci√≥n del sistema a los posibles cambios del mismo a lo largo del tiempo, minimizar el impacto 
de estos cambios en los diferentes componentes y/o dispositivos que interact√∫an con el sistema e 
independizar las funcionalidades de procesamiento y visualizaci√≥n de la plataforma tecnol√≥gica 
subyacente. [2] 
Tendiendo en cuenta estos objetivos y en funci√≥n del an√°lisis de las caracter√≠sticas funcionales y no 
funcionales descrito anteriormente, se dise√±√≥ una arquitectura de software basada en tres 
componentes: El primero es un componente de adquisici√≥n de informaci√≥n, que permite controlar 
diferentes dispositivos de hardware y recolectar se√±ales anal√≥gicas y digitales provenientes de los 
mismos. El segundo es un componente de procesamiento desarrollado con diferentes algoritmos de 
interpretaci√≥n, que permite identificar informaci√≥n relevante y seleccionar los elementos que deben 
ser visualizados. El tercero es un componente de visualizaci√≥n, que permite graficar informaci√≥n 
bajo diferentes configuraciones.  
2.4 Componente de Adquisici√≥n 
El Componente de Adquisici√≥n es responsable de implementar las funciones de lectura de las 
diferentes se√±ales que debe procesar el sistema. Se encuentra compuesto ‚Äìprincipalmente- de 
drivers de control de las distintas placas y dispositivos de hardware que brindan se√±ales de entrada 
al sistema. 
En este punto es importante considerar que las se√±ales que deben ser procesadas por el sistema 
provienen de diferentes dispositivos (Por ejemplo: antena del radar,  dispositivos de hardware 
asociados al radar, controles manuales, etc.), por lo cual el sistema debe poder sincronizar la 
recepci√≥n de se√±ales dis√≠miles y efectuar sobre los datos adquiridos las transformaciones necesarias 
para su futuro procesamiento. 
2.5 Componente de Procesamiento 
El componente de procesamiento tiene por objetivo procesar y analizar un conjunto de se√±ales de 
diferentes caracter√≠sticas. Adem√°s, seg√∫n las caracter√≠sticas del an√°lisis que deba realizarse, algunas 
se√±ales pueden requerir almacenamiento de informaci√≥n hist√≥rica (Algoritmos de seguimiento y 
predicci√≥n de trayectorias, estudio de frecuencia para reconocimiento de blancos, etc.). Por ende, 
este componente recibe por entrada un conjunto variable de datos que representan los distintos 
cambios en las se√±ales de entrada y, procesamiento mediante, produce como resultado el conjunto 
de datos que representan los distintos cambios en la informaci√≥n a visualizarse en el MFD. 
Las funciones de procesamiento que el sistema debe implementar dependen directamente del 
dominio de aplicaci√≥n del mismo. Existen al respecto numerosas t√©cnicas de procesamiento de 
se√±ales que tienen aplicaci√≥n directa en el desarrollo de sistemas de radares en distintos dominios. 
56
Las t√©cnicas basadas en an√°lisis de Fourier, por ejemplo, tienen importantes aplicaciones en 
numerosos sistemas de radar y se han desarrollado al efecto diferentes m√©todos de c√°lculo 
computacional aplicables; como ser el m√©todo de Cooley-Tukey, ampliamente utilizado en para 
an√°lisis de espectros y procesamiento digital de se√±ales de radar. [1] En particular, las t√©cnicas 
basadas en la Transformada R√°pida de Fourier (FFT ‚Äì Fast Fourier Transform) poseen variadas 
aplicaciones en este √°mbito, siendo utilizadas en radares de pulso Doppler, radares de seguimiento 
de blancos m√≥viles, en an√°lisis de vibraciones en sistemas de radares l√°ser, etc. [4]  
En el caso de radares t√°cticos resulta de suma importancia el problema del seguimiento de 
objetivos, en sus diferentes variantes. Al respecto se han propuesto diferentes enfoques para 
resolver el problema de seguimiento de un √∫nico objetivo, de m√∫ltiples objetivos o clasificaci√≥n de 
‚Äúfalsas alarmas‚Äù, es decir recepciones que aparentan ser un objetivo y no lo son. Estos enfoques 
incluyen t√©cnicas probabil√≠sticas, estimaci√≥n filtros de Kalman, entre otras. [3] 
2.6 Componente de Visualizaci√≥n 
El Componente de Visualizaci√≥n es responsable de implementar todas las funcionalidades de la 
Unidad de Visualizaci√≥n Multifunci√≥n (MFD). Por lo tanto, este componente no realiza ning√∫n tipo 
de procesamiento o transformaci√≥n de la informaci√≥n recibida, sino que provee funciones de 
configuraci√≥n de presentaciones gr√°ficas y modela en pantalla todo tipo de informaci√≥n que se 
estipule necesaria para el operador del sistema. 
En este punto resulta importante se√±alar que existen numerosos tipos de presentaciones, los cuales 
son utilizados seg√∫n las necesidades planteadas por los diferentes dominios de aplicaci√≥n (V√©ase 
secci√≥n 1). Adem√°s, existen convenciones asociadas tanto al tipo de informaci√≥n que debe 
presentarse como al dominio de aplicaci√≥n del sistema; por ejemplo, la iconograf√≠a utilizada para 
describir un elemento objetivo en el display es diferente en un sistema de radar de prop√≥sitos 
militares que en un radar de monitoreo de tr√°fico a√©reo de uso civil.  
3 ADQUISICI√ìN DE SE√ëALES 
El componente de adquisici√≥n fue dise√±ado con el objetivo de proveer funciones de adquisici√≥n de 
se√±ales, conversi√≥n de datos y sincronizaci√≥n de procesos de lectura de informaci√≥n.  
El componente se compone de drivers de control de los dispositivos de hardware involucrados y 
software de lectura de datos. Esta aplicaci√≥n de lectura interact√∫a con los distintos componentes 
obteniendo aquella informaci√≥n relevante para el sistema y lleva a cabo todas las transformaciones 
de datos requeridas por el mismo. Es decir: todas aquellas se√±ales anal√≥gicas que deban ser 
procesadas por el sistema son digitalizadas en este componente, por medio del control de placas 
conversoras anal√≥gico-digitales. Adem√°s, se implementan aqu√≠ todas las funciones de conversi√≥n de 
datos necesarias para que el componente de procesamiento reciba como entrada un conjunto de 
informaci√≥n estandarizada, seg√∫n un formato definido previamente.  
4 PROCESAMIENTO DE SE√ëALES 
4.1 Descripci√≥n General 
El componente de procesamiento fue dise√±ado de modo de poder analizar las diferentes se√±ales de 
entrada en tiempo real, calculando los valores correspondientes a los ¬´elementos¬ª u ¬´objetivos¬ª que 
componen las diferentes presentaciones y enviando dicha informaci√≥n al componente de 
visualizaci√≥n.   
Debe tenerse en cuenta que para calcular los datos correspondientes a algunos objetivos, es 
necesario analizar la informaci√≥n proveniente de varias se√±ales. Adem√°s, la informaci√≥n 
proveniente de algunas se√±ales debe ser utilizada en el c√°lculo de varios objetivos; raz√≥n por la 
57
cual, cualquier cambio en las se√±ales de entrada implica recalcular los datos correspondientes a 
todos los objetivos afectados por dicho cambio. 
Los datos de entrada recibidos desde el componente de adquisici√≥n y los datos de salida enviados al 
componente de visualizaci√≥n son transmitidos por estructuras de comunicaci√≥n denominadas 
¬´SignalPipe¬ª, implementadas por medio de sockets de protocolo TCP. Estas estructuras fueron 
implementadas con motivo de proveer una interface est√°ndar para la comunicaci√≥n entre los 
componentes del sistema.  
4.2 Implementaci√≥n del Componente 
El componente de Procesamiento del sistema (V√©ase Figura 2) se halla compuesto de: 
‚Ä¢ Una estructura de almacenamiento de informaci√≥n referida al conjunto de se√±ales de entrada 
especificado. 
‚Ä¢ Un conjunto de algoritmos de c√°lculo de todas las propiedades y objetivos que componen las 
presentaciones definidas. 
‚Ä¢ Una estructura de dependencias entre se√±ales de entrada y objetivos de salida. 
‚Ä¢ Referencias a las estructuras de comunicaci√≥n con el componente de adquisici√≥n y el 
componente de visualizaci√≥n. 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
La estructura de almacenamiento de se√±ales, implementada en la clase ¬´SignalBag¬ª,  mantiene en 
tiempo de ejecuci√≥n toda la informaci√≥n necesaria de las distintas se√±ales. Cada vez que se recibe 
un cambio correspondiente a una de sus se√±ales, se actualiza la estructura y se notifica a los 
objetivos afectados. Internamente esta estructura posee un buffer de almacenamiento para cada 
se√±al. Estos buffers son de longitud variable ‚Äìseg√∫n las caracter√≠sticas propias de cada se√±al- y 
pueden ser actualizados y recorridos f√°cilmente, tanto a los efectos de incorporar los nuevos datos 
como de utilizar los datos ya almacenados para calcular la informaci√≥n de visualizaci√≥n. 
El proceso de notificaci√≥n consta de la invocaci√≥n de las rutinas de c√°lculo de los objetivos 
afectados y el env√≠o de los datos actualizados al componente de visualizaci√≥n. Para poder llevar a 
cabo esta tarea, el componente cuenta con una estructura donde se consignan qu√© objetivos 
dependen de qu√© se√±ales. Esta estructura se denomina ¬´Matriz de Dependencias¬ª y contiene 
referencias a los algoritmos de procesamiento correspondientes a los distintos objetivos. Estos 
algoritmos son ejecutados por el m√©todo ¬´calcular¬ª.  
 
 SignalInterprete 
 
 
 
SignalPipe *pipeIn; 
 
 
 
 
SignalPipe *pipeOut; 
 
  
 
 
SignalBag *bag;  
 
 
 
 
 
 
S ignalInterprete(); 
 
 
 
 
 
 
void interpretarSenales(); 
 
 
 
 
void procesarPaquete(char *paquete); 
 
 
 
 
void notificarCambio(int signal); 
 
 
 
 
 
 
SignalPipe *pipeEntrada(); 
 
 
 
 
SignalPipe *pipeSalida(); 
 
 
SignalPipe 
  
   
 
SignalPipe 
  

 

 
	

 

  
Signal Bag 
 

 


 

  
notificarCambio(int signal){ 
 
 
  
 
Para todo 
 
 
‚Äú item ‚Äù 
 
 
afectado  por  ‚Äú signal ‚Äù : 
 
 
    
 
calcular [ signal ] [ item ] (); 
 
 } 
 
 
 
 
Matriz de  
Dependencias 
 
 


   
 
Figura 2: Diagrama de Implementaci√≥n del Componente de Procesamiento 
58
Las referencias a las estructuras de comunicaci√≥n con los componentes de adquisici√≥n y 
visualizaci√≥n son denominadas ¬´pipeIn¬ª y ¬´pipeOut¬ª, respectivamente.  
La clase ¬´SignalInterprete¬ª es la clase principal del componente e implementa el mecanismos de 
procesamiento de la se√±ales. El mismo es realizado por el m√©todo ¬´interpretarSenales¬ª (V√©ase 
Figura 3). 
El m√©todo ¬´interpretarSenales¬ª implementa la funci√≥n principal del componente; la cual recibe del 
pipe de entrada ¬´pipeIn¬ª los cambios en las se√±ales. Para cada paquete recibido, se invoca al 
m√©todo ¬´procesarPaquete¬ª, que actualiza los valores de las se√±ales en la estructura  ¬´bag¬ª e invoca 
las funciones de c√°lculo de los objetivos  afectados por el cambio, las cuales notifican sus resultados 
al pipe de salida ¬´pipeOut¬ª.  
 
 
Figura 3: Diagrama de interacci√≥n del m√©todo ¬´interpretarSenales¬ª 
4.3 Env√≠o y Recepci√≥n de Datos 
El env√≠o y recepci√≥n de informaci√≥n con los componentes de adquisici√≥n y visualizaci√≥n se lleva a 
cabo respetando las convenciones definidas por las estructuras de comunicaci√≥n de tipo 
¬´SignalPipe¬ª: 
‚Ä¢ Los mensajes deben ser textuales y deben respetar un formato de ternas ELEMENTOATRIBUTO-VALOR.  
‚Ä¢ En algunos casos los mensajes que deben enviarse corresponden a duplas ELEMENTOVALOR, para lo cual se adjuntar√° un valor cero (‚Äú0‚Äù) al tercer campo.  
En el caso de los mensajes recibidos por el componente se utiliza el formato de duplas, donde el 
campo ELEMENTO se corresponde con un identificador de se√±al de entrada y el campo VALOR se 
corresponde, naturalmente, con el valor num√©rico de la misma. 
En el caso de los mensajes enviados al componente de visualizaci√≥n, en cambio, se utiliza el 
formato de ternas, donde el campo ELEMENTO se corresponde con un identificador del elemento 
 SignalInterprete 
InterpretarSenales() 
pipeIn 
recibir() 
paquete 
leerBuffer() 
procesarPaquete() 
SignalBag 
addSignal() 
Dependencia 
notificarCambio() 
calcular[Signal][Item1]() 
calcular[Signal][Item2]() 
calcular[Signal][ItemN]() 
pipeOut 
enviar() 
enviar() 
enviar() 
59
objetivo en la presentaci√≥n, el campo ATRIBUTO se corresponde con una propiedad del elemento 
objetivo y el campo VALOR con el valor num√©rico asociado. 
5 VISUALIZACI√ìN DE INFORMACI√ìN 
5.1 Descripci√≥n General 
Resulta importante se√±alar que la unidad de visualizaci√≥n multifunci√≥n (MFD) debe componerse 
de, al menos, una ‚Äúvista‚Äù o ‚Äúpresentaci√≥n‚Äù. Entendiendo por vista un conjunto de informaci√≥n 
gr√°fica o textual que se presenta al usuario mediante un formato determinado oportunamente.  
El componente de visualizaci√≥n fue dise√±ado de modo de poder soportar varias vistas en paralelo, 
con diferentes formatos y convenciones, pudiendo las mismas ser modificadas o reemplazadas de 
manera flexible. A tal efecto, se definieron dos elementos fundamentales: ¬´√çtem graficable¬ª y 
¬´Presentaci√≥n¬ª.  
Un √çtem graficable es cualquier elemento gr√°fico o informaci√≥n textual que deba ser presentado en 
el MFD; por ejemplo: un contacto, la regla de escala, la informaci√≥n de modo de barrido del radar, 
el fondo de la ventana donde se muestran los dem√°s √≠tems, etc. 
Una Presentaci√≥n es b√°sicamente un conjunto de √≠tems graficables. Una presentaci√≥n puede ser una 
gr√°fica sinusoide que describa los valores de una determinada se√±al del RADAR, un diagrama de la 
zona explorada por el radar o bien una lista de datos num√©ricos que informen al operador 
informaci√≥n asociada con un objetivo. Todos estos ejemplos pueden ser presentaciones diferentes 
de una misma situaci√≥n. Cada tipo de presentaci√≥n puede ser de mayor o menor utilidad seg√∫n sea 
la necesidad. En todo caso, el presente dise√±o contempla la posibilidad de desarrollar cualquier tipo 
de presentaci√≥n de manera f√°cil y eficiente. 
5.2 Implementaci√≥n del Componente 
El componente de visualizaci√≥n fue desarrollado con el objetivo de poder manipular eficientemente 
informaci√≥n gr√°fica y textual (√çtems graficables) organizada en forma de presentaciones, las cuales 
deben ser implementadas en funci√≥n de formatos de configuraci√≥n definidos. Adem√°s, cabe aclarar 
que tanto los valores como las propiedades o par√°metros visuales (color, tama√±o, etc.) de los √≠tems 
graficables deben actualizarse en tiempo real. 
Estas funcionalidades fueron implementadas de la siguiente manera: 
‚Ä¢ En primer t√©rmino, se desarroll√≥ la clase ¬´VistaRadar¬ª con el objeto de resolver todas las 
funciones propias de una presentaci√≥n.  
‚Ä¢ Los √≠tems graficables fueron modelados por medio de la clase ¬´ItemGrafico¬ª.  
‚Ä¢ Los formatos de las presentaciones son especificados a trav√©s de archivos de configuraci√≥n, 
de forma tal de poder alterar el aspecto de la presentaci√≥n sin necesidad de modificar o, 
incluso, recompilar el sistema.  
‚Ä¢ Finalmente, los cambios en la informaci√≥n presentada son recibidos a trav√©s de una 
estructura de comunicaci√≥n con el componente de procesamiento del sistema (V√©ase secci√≥n 
4.3). 
 
60
 Figura 4: Diagrama de Implementaci√≥n del Componente 
 
La clase ¬´VistaRadar¬ª (V√©ase Figura 4) setea el formato de visualizaci√≥n de la vista descargando la 
informaci√≥n desde un archivo de configuraci√≥n definido previamente. El objetivo del archivo de 
configuraci√≥n es definir los formatos propios del sistema de representaci√≥n y la iconograf√≠a a 
utilizar.  
En tiempo de ejecuci√≥n, la configuraci√≥n de la presentaci√≥n se almacena en una estructura interna 
denominada ¬´Matriz de Configuraci√≥n¬ª; la cual almacena tambi√©n informaci√≥n de los cambios que 
producen en el presentaci√≥n en funci√≥n de los distintos cambios en el estado del sistema (Por 
ejemplo: cambio en el modo de operaci√≥n del radar, detecci√≥n de un objetivo espec√≠fico, etc.). 
Adem√°s, tambi√©n es posible cambiar el formato de representaci√≥n en tiempo de ejecuci√≥n, para lo 
cual s√≥lo debe actualizarse esta Matriz a partir de la informaci√≥n proveniente de otro archivo de 
configuraci√≥n. 
Los √≠tems graficables se encuentran en una estructura de tipo arreglo denominada ¬´presentaci√≥n¬ª 
(V√©ase Figura 4). La misma es seteada a partir de la Matriz de Configuraciones y, conforme se 
obtienen los datos de las actualizaciones de los distintos √≠tems graficables (Por ejemplo: cambios en 
la localizaci√≥n de un contacto, cambio en el modo de operaci√≥n del radar, etc.) se modifica, de 
modo tal de proveer una representaci√≥n interna a la vista respecto de la situaci√≥n a ser presentada en 
el MFD.  
5.3 Implementaci√≥n de Presentaciones 
Una presentaci√≥n se compone de un conjunto de elementos objetivos denominados ‚Äú√≠tems 
graficables‚Äù. Cada √≠tem es representado en el sistema como una instancia de la clase abstracta 
¬´ItemGrafico¬ª. 
La clase ¬´ItemGrafico¬ª define el comportamiento y las propiedades que caracterizan a un elemento 
de una presentaci√≥n. Resulta importante se√±alar que para construir una presentaci√≥n debe dise√±arse 
una clase para cada tipo de √≠tem que la compondr√° y que las mismas deben ser subclases de 
¬´ItemGrafico¬ª. De esta forma, cada subclase implementa el comportamiento definido por la 
superclase y se obtiene un mecanismo unificado de tratamiento de los distintos elementos gr√°ficos 
que conformar√°n las presentaciones del sistema. 
Cada √≠tem graficable se define seg√∫n un conjunto de propiedades comunes a todos (Por ejemplo: 
nombre, posici√≥n en el eje X, posici√≥n en el eje Y, color, etc.), cuyos valores se inicializan en 
funci√≥n del formato de representaci√≥n establecido en la Matriz de configuraci√≥n (y √©sta a su vez del 
contenido del archivo de configuraci√≥n correspondiente) y se actualizan en tiempo real en funci√≥n 
de la informaci√≥n de cambios provenientes del componente de interpretaci√≥n. 
Dado que muchos de los elementos a presentar en el MFD constituyen informaci√≥n textual, se 
defini√≥ tambi√©n una clase abstracta que define el comportamiento espec√≠fico de un √≠tem graficable 
textual. Esta clase se denomina ¬´TextoG¬ª. 
VistaRadar 
FILE *configurationFile; 
SignalPipe *entradas; 
ItemGrafico *presentacion[MaxItems]; 
int 
configuracion[MaxItems][MaxSettings];
void setEntradas(SignalPipe *ins); 
void setConfiguracion(char *nombre); 
void setVisualizacion(); 
void setPresentacion(); 
void visualizarPresentacion(); 
Archivo de 
Conf. 
SignalPipe 
ItemGrafico 
ItemGrafico 
ItemGrafico 
ItemGrafico 
Arreglo de Items  
ItemGrafico 
Matriz de 
Conf. 
61
5.4 Configuraci√≥n de Presentaciones 
El objetivo del mecanismo de configuraci√≥n a trav√©s de archivos es brindar flexibilidad a la 
manipulaci√≥n de formatos de presentaciones. Este mecanismo permite que el sistema reciba toda la 
informaci√≥n necesaria para mostrar una presentaci√≥n por pantalla desde un archivo independiente 
del sistema mismo (V√©ase Figura 5). De esta forma, si se respetan las convenciones adecuadas, es 
posible modificar archivos de configuraci√≥n sin necesidad de recompilar el sistema. 
 
 
Figura 5: Interacci√≥n del Sistema con los Archivos de Configuraci√≥n 
 
Para cada representaci√≥n que se desee proveer desde el sistema es necesario codificar un archivo de 
configuraci√≥n asociado. Los archivos de configuraci√≥n incluyen una definici√≥n clara de los distintos 
√≠tems graficables que incluye una determinada presentaci√≥n, as√≠ como tambi√©n los valores 
correspondientes a sus propiedades internas.  
Estos √≠tems o elementos de las presentaciones permiten definir vistas que se adecuen a las 
necesidades espec√≠ficas de cada dominio de aplicaci√≥n. Por ejemplo, un √≠tem que debe definir cada 
presentaci√≥n es el fondo de la misma, el cual puede ser tanto un color como un mapa o una 
fotograf√≠a satelital, lo que sirve tanto a los fines de un radar de tr√°fico a√©reo como a radar 
meteorol√≥gico. Adem√°s, el sistema provee la capacidad de presentar en pantalla informaci√≥n 
textual, en diferentes tipograf√≠as y tama√±os; gr√°ficos elementales, como ser l√≠neas o c√≠rculos; e 
im√°genes en distintos formatos, de modo de poder identificar un cierto objetivo mediante una 
representaci√≥n gr√°fica del mismo (una imagen de un barco, una nube, una bandera o cualquier otro 
s√≠mbolo distintivo). 
6 IMPLEMENTACI√ìN 
A modo de caso de estudio, se implement√≥ un sistema de software seg√∫n las caracter√≠sticas descritas 
en las secciones anteriores.  
El sistema ha sido programado √≠ntegramente en lenguaje ANSI/C. en funci√≥n de las caracter√≠sticas 
de administraci√≥n de procesos y prestaciones para sistemas de tiempo real, ha sido implementado 
sobre un sistema operativo Linux Sarge.  
6.1 Adquisici√≥n de Se√±ales 
En lo que respecta a la plataforma tecnol√≥gica utilizada, se implementaron controladores para dos 
dispositivos de adquisici√≥n de se√±ales anal√≥gicas y digitales. La primera es una placa de tipo PCI 
provista por la empresa Measurement Computing, modelo PCI-DAS-4020/12 (V√©ase Figura 6-A).  
La segunda es una placa de tipo PCI provista por la empresa Eagle Tecnology, modelo PCI-703S 
(V√©ase Figura 6-B). 
Proceso en Ejecuci√≥n: 
Sistema de Procesamiento y 
visualizaci√≥n de Se√±ales de 
RADAR Componente de 
Visualizaci√≥n 
 
 
MFD 

Vista1.conf 
Archivos De Configuraci√≥n 
62
La placa PCI-DAS-4020/12 posee 4 canales de entradas anal√≥gicas, 2 canales de salidas anal√≥gicas 
y 24 canales de entrada/salida digitales. Esta placa opera con una resoluci√≥n de 12 bits y permite 
muestrear datos a una frecuencia de hasta 20MHz. 
La placa PCI-703S posee 8 canales de entradas anal√≥gicas, 2 canales de salidas anal√≥gicas y 8 
canales de entrada/salida digitales. Esta placa opera con una resoluci√≥n de 14 bits y permite 
muestrear datos a una frecuencia de 400KHz. 
 
 
 
 
 
 
 Figura 6-A: Placa PCI-DAS4020/12 
 Figura 6-B: Placa PCI-703S  
 
Con estas placas es posible obtener una amplia variedad de se√±ales, de diferentes frecuencias y 
caracter√≠sticas, de modo de poder poner en pr√°ctica diferentes algoritmos de interpretaci√≥n. 
6.2 Procesamiento de Se√±ales 
Los algoritmos de interpretaci√≥n de se√±ales utilizados hasta el momento permiten efectuar 
operaciones de filtrado de ruido, identificaci√≥n de posibles objetivos y c√°lculo de distancias de los 
objetivos identificados. Actualmente, se encuentran en etapa de estudio algoritmos de seguimiento 
de objetivos y reconocimiento autom√°tico. 
6.3 Visualizaci√≥n de Informaci√≥n 
Diferentes presentaciones han sido programadas y puestas en pr√°ctica. La mayor√≠a de las mismas 
son variaciones de las presentaciones tipo B, las cuales ubican en el display los distintos objetivos 
identificados en una representaci√≥n cartesiana seg√∫n la informaci√≥n de distancia (Eje Y) y azimuth 
(Eje X).  
Adem√°s, se implementaron presentaciones tipo A, las cuales muestran en el display una 
representaci√≥n cartesiana seg√∫n la informaci√≥n de amplitud de las se√±ales recibidas por la antena 
(Eje Y) y distancia (Eje X) [1].  
6.4 Estado Actual 
El estado de avance actual del sistema permite adquirir, interpretar y visualizar informaci√≥n de un 
sistema de radar, bas√°ndose en se√±ales producidas por un generador. De esta forma, a un nivel de 
simulaci√≥n es posible estudiar diferentes algoritmos de procesamiento as√≠ como implementar 
diferentes mecanismos de presentaci√≥n de informaci√≥n. 
7 CONCLUSIONES Y TRABAJO FUTURO 
Seg√∫n las pruebas efectuadas hasta la fecha, es posible concluir que el sistema desarrollado puede 
ser aplicado con √©xito en diferentes sistemas de radar existentes, con el objetivo de implementar 
cambios, actualizaciones o mejoras en los mismos.  
63
La arquitectura de software propuesta result√≥ satisfactoria para garantizar el cumplimiento de los 
requisitos funcionales y no funcionales contemplados. De todos modos, resulta cr√≠tico aplicar este 
sistema en diferentes plataformas tecnol√≥gicas, de modo de poder probar las prestaciones 
funcionalidades del mismo en distintos dominios de aplicaci√≥n. 
A corto plazo, es de suma importancia implementar diferentes algoritmos de procesamiento de 
se√±ales. En primer t√©rmino, deben desarrollarse algoritmos de reconocimiento autom√°tico y de 
seguimiento de objetivos y/o trayectorias. 
El desarrollo de nuevas presentaciones resulta tambi√©n un aspecto de singular importancia, pues 
permite adaptar el sistema actual a nuevos y diferentes dominios de aplicaci√≥n. 
8
