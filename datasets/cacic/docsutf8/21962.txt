Verificaci√≥n de propiedades temporales en PPML
Ôªø
Product Process Modeling Languaje(PPML) is a formal language for the specification
of Business Processes, it has a formal semantics based on timed transition systems. The
language has artifacts that make it suitable for the formal specification of Business Processes with temporal restrictions, concurrency, etc. . Nevertheless, there is no support
tool for the language. Particulary, the language lacks tools for the verification of temporal properties associated to specifications. In this paper we propose, first, a codification
of the PPML semantics into timed automatas through a translation from PPML to the
language UPPAAL. Second, we use this translation, that was automated in a prototype,
in order to verify CTL (branching time) propierties of the PPML specifications, using the
UPPAAL asociated tool.
Keywords: Formal Methods, Model Checking, Timed Automatas, Business Processes
Resumen
Product Process Modeling Languaje(PPML) es un lenguaje formal para modelar Procesos de Negocios que posee una sem√°ntica basada en sistemas de transici√≥n de estados
temporizados. El lenguaje posee elementos que lo hacen apropiado para la especificaci√≥n
formal de procesos de negocios con restricciones temporales, concurrencia, etc. Sin embargo, no existe actualmente ninguna herramienta de soporte al lenguaje; en particular,
el lenguaje carece de herramientas de verificaci√≥n de propiedades temporales asociadas a
las especificaciones. En este trabajo proponemos, en primer lugar, una codificaci√≥n de la
sem√°ntica de PPML en aut√≥matas temporizados, a trav√©s de una traducci√≥n de PPML al
lenguaje UPPAAL. En segundo lugar, aprovechamos esta traducci√≥n, que ha sido automatizada en un prototipo, para realizar verificaci√≥n de propiedades CTL (branching time)
de especificaciones PPML, utilizando la herramienta asociada a UPPAAL.
Palabras Clave: M√©todos Formales, Model Checking, Aut√≥matas Temporizados, Procesos
de Negocios
1
1 Introducci√≥n
El constante esfuerzo de distintas organizaciones por el perfeccionamiento de sus procesos en
busca de eficiencia y control, ha impulsado el actual auge de diversos m√©todos y lenguajes para
el modelado de procesos de negocios. Si bien existen diversos lenguajes como Business Process
Execution Language(BPEL) entre otros, en su gran mayor√≠a est√°n orientados a servicios y en
general no proveen una sem√°ntica formal que nos permitan realizar an√°lisis formales. PPML
[9] es un lenguaje para el modelado de procesos de negocios con una sem√°ntica formal basada
en sistemas de transici√≥n de estados temporizados [8]. Sus modelos se construyen mediante
la especificaci√≥n y composici√≥n de procesos y su interacci√≥n con los productos que manipulan.
PPML ofrece una variedad de elementos, en particular la asignaci√≥n de cotas temporales a los
procesos, que lo hacen adecuado para la especificaci√≥n formal de procesos en los cuales existan
restricciones temporales, sincronizaci√≥n entre componentes, concurrencia en las tareas, etc..
Pese a las ventajas mencionadas, a√∫n no existe ninguna herramienta que asista la creaci√≥n de
modelos y que permita obtener informaci√≥n de propiedades que estos cumplan.
En los √∫ltimos a√±os, se han conseguido significativos avances en el desarrollo de t√©cnicas y
herramientas para la verificaci√≥n de requerimientos, una de las m√°s conocidas es Model checking [4] cuya combinaci√≥n con el uso de lenguajes formales nos permiten automatizar el procesos
de verificaci√≥n. Entre las herramientas m√°s utilizadas de Model checking para sistemas de
tiempo real, se pueden mencionar Kronos [6] y Uppaal [1]. Uppaal est√° basada en la teor√≠a de
aut√≥matas temporizados y provee un subconjunto de Computational Tree Logic(CTL)[10, 11, 3]
como lenguaje de especificaci√≥n de cosultas.
En el presente trabajo presentamos la utilizaci√≥n de Uppaal para la verificaci√≥n de propiedades
temporales de modelos especificados en PPML. Para ello se propone una traducci√≥n de los
modelos al lenguaje que utiliza Uppaal y as√≠ poder consultar la valid√©s de dichas propiedades.
Como caso de estudio mostraremos una versi√≥n simplificada de una l√≠nea de producci√≥n de una
compa√±¬¥ƒ±a de MotherBoards.
Primeramente se daremos una descripci√≥n del lenguaje PPML, una introducci√≥n a Uppaal y
luego mostraremos la traducci√≥n propuesta junto con las propiedades verificadas. Para finalizar
mencionaremos el trabajo presente y futuras extensiones del mismo.
2 Descripci√≥n de PPML
PPML es un leguaje formal para modelar Procesos de Negocios, est√° basado en el m√©todo
descripto en [12]. El M√©todo consta tres tipos de construcciones b√°sicas: Productos, Procesos y
Puertas. Los Productos son entidades representadas por un conjunto de atributos. Los Procesos
son entidades que pueden manipular, transformar productos. √âstos son caraterizados por su
comportamiento en el tiempo teniendo como resticci√≥n, s√≥lo un producto de entrada y uno de
salida. Esta restricci√≥n revela la necesidad de poder empaquetar y desmpaquetar productos
mediante Puertas.
2.1 Productos
Los Productos capturan las caracter√≠sticas relevantes del modelo emp√≠rico, por ejemplo altura,
peso, color, etc. Estas caracter√≠sticas pueden ser directamente observables o calculables a partir
de otras mediante funciones, adem√°s son determinadas en base a una escala apropiada.
Definimos Productos como: at√≥micos, compuestos o estructurados.
2
‚Ä¢ Un Producto At√≥mico P es una 5-upla < codigoP , nombreP , tiempoP , atributosP , <
Œ£P , AP >> donde: codigoP es una constnate del conjunto Codigo, distingue un√≠vocamente
cada producto, nombreP es una constante del conjuntoNombre, tiempoP es una constnate
del conjunto Time (time stamp del producto), atributosP es un conjunto de constantes de
Œ£P , representando las caratecr√≠sticas que queremos modelar del referente emp√≠rico. Los
atributos pueden ser directos o derivados, √©stos √∫ltimos obtienen su valor a partir de otros
por medio de axiomas AP . < Œ£P , AP > es la teor√≠a de presentaci√≥n, el proto-producto que
consta de todas las constantes definidas. La igualdad de productos queda determinada
por al igualdad de la especificaci√≥n del proto-producto.
‚Ä¢ Un Producto Compuesto P es : o bien, un par P =< codigoP , ‚äó(Pc1, .., Pcn) > donde
‚äó(Pc1, .., Pcn) es una inyecci√≥n de los componentes Pci en el producto cartesiano ( usado
para sincronizar y empaquetar varios productos como entrada de un proceso ), o bien,
un par P = codigoP , Œπ(P) donde P es un conjunto finito de productos y Œπ(P) ‚àà P (
utilizado en situaciones donde el producto de entrada es elegido en base a una condici√≥n).
Los productos compuestos no tienen nombres y tiempos ya que son una construcci√≥n del
m√©todo y no representan referentes emp√≠ricos.
‚Ä¢ Un Producto Estructurado P puede ser: Especializado o refinado, se extiende
uno definido agregando nuevas constantes, funciones y relaciones. Agregado, permite
combinar varios productos como constituyentes de un nuevo producto. Los atributos de
los productos agregados pueden ser atributos de sus constituyentes o nuevos atributos y
su proto-producto es una especializaci√≥n de la uni√≥n disjunta de los proto-produtos que
lo conforman.
Como ejemplo, supongamos que queremos modelar una versi√≥n simplificada de una l√≠nea de
producci√≥n de una compa√±¬¥ƒ±a de MothoerBoards; en la cual tenemos un producto MotherBoard
con un slot para un procesador y un slot para un banco de memoria y como producto terminado
la versi√≥n ensamblada y testeada de los tres componentes. Por cuestiones de espacio s√≥lo se
mostrar√° la especificaci√≥n de algunas partes del modelo.
Product MotherBoard <
<MProccessor: Proccessor ; MMemory:Memory > ,
weight ,
HasProccessor ,
Proccessor_Socket ,
HasMemory >
Figura 1: Producto estructurado MotherBoard
Podemos observar que las precedentes definiciones representan los que en Orientaci√≥n a Objetos llamamos clases. As√≠ llamaremos instancias a los referentes emp√≠ricos que se corresponden
con dichas clases; estas instancias de productos son las tendr√°n lugar en la ejecuci√≥n de los
procesos. Una instancia de un producto P =< c, n, t, att, T > es un una interpretaci√≥n en el
sentido l√≥gico de T .
En el mundo real existen situaciones en las que un producto va evolucionando en la medida
en que es procesado, es decir, existen situaciones en las que se desconocen ciertos atributos del
mismo; o en caso de ser un producto estructurado, situaciones en las cuales a√∫n no se le ha
asociado alguno de sus componentes. Para ello por cada dominio necesitamos definir valores
que se correspondan a estas situalciones (valores nulos).
3
2.2 Procesos
Un proceso modela un referente emp√≠rico que transforma un producto de entrada en uno de
salida. Al igual que los productos, los procesos pueden ser at√≥micos (sin estructura interna
o subprocesos) o estructurados. Los procesos modelan transformaciones, para ello, por cada
proceso existe una m√°quina virtal que interpreta sus comandos b√°sicos. Esta m√°quina virtual
es un objeto con m√©todos, por ejemplo, asignaci√≥nes a variables. Para especificar un proceso,
definimos las transformaciones √©ste realiza usando acciones b√°sicas o combinaciones de estas
por medio de estructuras de control. La formalizaci√≥n del concepto de m√°quina virtual [7]
consiste en un framework l√≥gico sobre sistemas de transici√≥n de estados llamado RETOOL
[2]. La especificaci√≥n es un par que contiene una signatura y una conjunto de sentencias que
describen su comportameinto.
La definici√≥n de un proceso es una transacci√≥n, un segmento de computaci√≥n de la m√°quina
virtual subyacente. Consta de la condici√≥n inicial q (estados que satisfacen las condiciones
iniciales), la condici√≥n final p ( estados que satisfacen la condici√≥n final de la transacci√≥n), el
Invariante I ( sentencia que debe evaluarse verdadera en todos los estados de la traza) y las
cotas inferior y superior l, u que especifican el tiempo m√≠nimo y m√°ximo que puede demorar en
completarse. Formalmente (q, I)l‚àÜup, y su sem√°ntica: œÉ, T, i  (q, I)l‚àÜup si y s√≥lo si para alg√∫n
j, k tal que i+ 1 ‚â§ j < k ‚â§ i+ u, tenemos para cada i ‚â§ m ‚â§ j que œÉ, T,m  q; œÉ, T, k  p, y
para cada j ‚â§ n ‚â§ k tenemos œÉ, T, n  I.
Un Proceso At√≥mico p es un par < proc, V M >, donde VM =< Œ∏,Œò > y proc =< codigo,
nombre, propietario, PI , PO, (q, I)l‚àÜup >. codigo, nombre, propietario son variables de los
correspondientes conjuntos y son fijos, es decir, no cambian durante trazas de c√≥mputo. PI , PO
son los productos de entrada y salida, y (q, I)l‚àÜup es la especificaci√≥n del comportamiento del
proceso.
Como ejemplo se muestra el proceso que toma una MotherBoard sin ensamblar y un Procesador y devuelve la MotherBoard con el procesador ensamblado. El producto de entrada ser√°
un paquete con ambos productos de entrada. Como condici√≥n inicial especificamos la compatibilidad de los socket de conexi√≥n y que la MotherBoard no tenga asemblado el Procesador. El
invariante requiere que no puede ser asemblado simultaneamente la memoria, y como producto
de salida retorna la MotherBoard con el Procesador ensamblados. Adem√°s especificamos que
el proceso tomar√° como m√≠nimo 5 unidades de tiempo y 10 como m√°ximo.
Process assem 1 <
input: ‚äó(<Mother_in:Motherboard;Proc_in:Proccessor>)
output: MotherBoard
invariant: Mother_in.HasMemory = false
requires: Mother_in.Proccessor Socket = Proc_in.Proccessor Socket
‚àß Mother_in.HasProccessor=false
ensure: output=<<Mother_in,Proc_in,item> , true, false>
l_time: 5 , u_time:10 >
Figura 2: Proceso que ensambla un Procesador en una Motherboard
2.3 Puertas
Usaremos el concepto de puertas para modelar construcciones que necesitamos en el lenguaje,
por ejemplo, cuando un proceso necesita varios productos o para distribuir varios productos
como entrada a procesos o para organizar sincronizar el control del sistema cuando cierta
condici√≥n debe ser cumplidad para poder continuar. Exiten tres tipos b√°sicos de puertas:
4
‚Ä¢ Multiplexor es una 4-upla < codigo, P , P , F > donde codigo es una variable est√°tica
que la identifica, P es el conjunto de productos de entrada, P es el producto de salida y
F es la funci√≥n que define cada Pi expl√≠citamente en terminos de P .
‚Ä¢ Demultiplexor , definici√≥n sim√©trica a la anterior, en este caso los productos de salida
son proyecciones sobre producto de entrada.
‚Ä¢ Sem√°foro es una 3-upla < codigo, P, S,> donde P es el producto de entrada/salida y S
es la condici√≥n que debe satisfacerse para continuar. Gr√°ficamente:
P1
...
Pn
M
P
Figura 3: Multiplexer
P
D
P1
...
Pn
Figura 4: Demultiplexer
P
S
P
Figura 5: Semaphore
2.4 Frameworks
En el proceso de modelar sistemas, al igual que en programaci√≥n, necesitamos abstracci√≥n
y encapsulamiento como herramientas. PPML provee estructuras de procesos framework
process a trav√©s de las diferentes formas de combinar procesos:
‚Ä¢ Composici√≥n Sequencial: compone dos procesos p1, p2 (denotado p1; p2 ) en uno nuevo
p de la siguiente manera: el codigo y nombre de p tienen un nuevo y √∫nico codigo y
nombre respectivamente, el propietario ser√° la entidad responsable de p. La entrada de
p ser√° la de p1 y su salida la de p2. La funci√≥n de transici√≥n œÑ es (qp, Ip)lp‚àÜ
uppp donde: lp
es la cota inferior del primer proceso, up es la suma de las cotas superiores, qp es q1, pp
es p2 y Ip es q1U>lp1 (Ip1U‚â§up1‚àílp1 (pp1 ‚Üí trueU(qp2U>lp2 (Ip2U‚â§up2‚àílp2pp2))))
El invariante requiere que la condici√≥n inicial del primer proceso se mantenga almenos
hasta lp1 , a partir de ese punto el invariante de p1 debe ser cierto durante up1‚àílp1 unidades
de tiempo, cuando la condici√≥n final pp1 se torna verdadera. Eventualemente la condicion
inicial qp2 ser√° verdadera almentos hasta lp2 , en ese momento comezar√° la valid√©z de la
invarte Ip2 durante un tiempo no superior a up2 ‚àí lp2 justo en el punto en el cual se
cumple la condici√≥n final pp2 . Cabe destacar que deben concordar las especificaciones
de los produtos de salida de p1 y entrada p2. El tiempo entre el estado final de p1 y el
inicial de p2 no es tenido en cuenta en el modelo, en caso de querer reflejar cierto tiempo
que manifieste el referente emp√≠rico, debe√≠amos componer otro proceso intermedio que lo
refleje. Denotamos la composici√≥n secuencial como p1; p2.
‚Ä¢ Composici√≥n Condicional (Sem√°foros): Denotado por p1;s p2 es el proceso p =<
codigo, nombre, propietario, Pi, Po, œÑ > con una definici√≥n an√°loga a la anterior, y cuyo
invariante est√° dado por:
q1U>lp1 (Ip1U‚â§up1‚àílp1 (pp1 ‚Üí trueU((qp2 ‚àß Ss)U>lp2 (Ip2U‚â§up2‚àílp2pp2)))).
‚Ä¢ Composici√≥n Paralela: Denotada por [p1; p2](dI ,mO) es: codigo, nombre y propietario
an√°logos a las definiciones anteriores; la entrada de p es la del demultiplexor dI , la salida
5
es la del multiplexor mO y la funci√≥n œÑ de p es (qp, Ip)lp‚àÜ
uppp: lp es m√°ximo (lp1 , lp1), up
es m√°ximo (lp1 , lp1), qp es q1 ‚àß q2 ,
pp es p1 ‚àß p2, y Ip es (q1 ‚àß q2)‚Üí (œÑ1[(p1U(p1 ‚àß p2))/p1] ‚àß (œÑ2[(p2U(p1 ‚àß p2))/p2])) (donde
œÑ [(pUq)/r] significa el reemplazo de la condici√≥n final r en œÑ por la condici√≥n (pUq)).
Un framework process p es un Proceso at√≥mico definido a trav√©s de un conjunto de procesos
{p1, ..., pn} que lo forman en t√©rminos de las distintas composiciones definidas anteriomente y
lo denotamos con el par < p, fw.exp >, donde p es la difinici√≥n cl√°sica de proceso y fw.exp es
la especificaci√≥n de los procesos que lo forman en t√©rminos de composiciones entre ellos.
3 Uppaal
Uppaal es una herramienta para la verificaci√≥n de sistemas de tiempo real. Est√° basada en
la teor√≠a de aut√≥matas temporizados y provee un subconjunto de CTL (Computational Tree
Logic) como lenguaje de especificaci√≥n de cosultas. Un modelo de un sistema en Uppaal es un
conjunto de instancias de esquemas que se comunican por medio de distintos tipos de canales. La
especificaci√≥n consta de tres partes: Declaraciones Globales, Esquemas ( Automata Templates)
con sus Declaraciones Locales y la Especificaci√≥n del Sistema.
3.1 Declaraciones
Las declaraciones globales, o locales a un esquema, contienen definiciones de variables, arreglos,
registros y tipos (estilo lenguaje C). Existen cuatro tipos predefinidos: int (enteros), bool
(l√≥gicos), clock (relojes), and chan (canales); √©stos ultimos puden ser canales urgent o broadcast.
Tambi√©n pueden definirse constantes anteponiendo el prefijo const. Uppaal provee un lenguaje
rico para la declaraci√≥n de funciones que pueden ser invocadas dentro de los los esquemas,
podemos especificar par√°metros, sentencias condicionales, sentencias iterativas como While y
For.
3.2 Esquemas
Los Esquemas son definidos en forma de Aut√≥matas Temporizados Extendidos ; pudiendo en
ellos leer y modificar relojes, variables, invocar a funciones definidas, etc. El aut√≥mata de
un esquema cosiste en Estados y Aristas, tambi√©n pueden contener declaraciones locales y
par√°metros por valor o referencia.
Los Estados pueden estar etiquetados (nombres que los referencian). Tambi√©n podemos
especificar invariantes en los estados, esto es, una condici√≥n que siempre debe cumplirse. Las
expresiones permitidas como invariantes son restringuidas, s√≥lo pueden ser una conjunci√≥n de
condiciones simples sobre relojes o expresiones l√≥gicas que no contengan relojes. No se permiten
condiciones que involucren cotas inferiores sobre relojes. Existen tres modificadores para los
estados de esquemas: Inicial, cada esquema debe tener exactamente un estado inicial. Urgentes,
detienen el paso del tiempo mientras un proceso se encuetre en uno de ellos. Comprometidos,
al igual que los urgentes detienen el paso del tiempo, adem√°s obliga que la pr√≥xima transici√≥n
debe tomar alguna arista que comienze en un estado comprometido habilitado.
Los estados est√°n conectados por medio de Aristas, en ellas se pueden definir: selectores,
guardas, sincronizaciones y modificaciones. Los selectores retornan aleatoreamente un valor de
un rango especificado. Una arista esta habilitada si y s√≥lo si la condici√≥n de su guarda se cumple,
6
las condiciones de las guardas tienen las mismas restricciones que las de los invariantes. Los
procesos pueden sincronizarse compartiendo un canal, en el cual uno escribe (!) y el otro escucha
(?), s√≥lo se permite un canal por arista. Cuando las aristas son ejecutadas, las expresiones de
modificaciones son evaluadas y su efecto cambia el estado del sistema.
Cuando dos procesos son sincronizados, ambas aristas de los procesos son ejecutadas. Las
modificaciones de ambos se realizan se realiza en orden, primero evaluando las del proceso
que escribe y luego las del que escucha. Los canales Broadcast perminten sincronizacioes de
1-a-muchos, esto es, un proceso escribe en un canal y todos aquellos con aristas habilitadas en
escucha de dicho canal ser√°n invocados.
3.3 Especificaci√≥n del Sistema
La Especificaci√≥n de un modelo de sistema consiste de uno o mas procesos concurrentes (instancias de esquemas), variables y canales de comunicaci√≥n. Las variables, canales y funciones
definidas aqui no son visibles para los esquemas.
3.4 Propiedades Temporales
Uppaal soporta como lenguaje de consultas, l√≥gica temporal CTL [ ref ] con ciertas restricciones,
s√≥lo pude haber un cuantificador de caminos. As√≠ las consultas que podemos realizar son de la
forma:
‚Ä¢ E  q: se evalua como verdadera si y s√≥lo si existe una secuencia de transiciones s0 ‚Üí
¬∑ ¬∑ ¬∑ ‚Üí sn donde s0 es el estado inicial y en sn satisface q.
‚Ä¢ A[]q: es verdadera si y s√≥lo si todo estado alcanzable satisface q.
‚Ä¢ E[]q: es verdadera si y s√≥lo si existe una secuencia de transiciones s0 ‚Üí s1 ‚Üí ¬∑ ¬∑ ¬∑ ‚Üí si ‚Üí
¬∑ ¬∑ ¬∑ donde todo si satisface q.
‚Ä¢ A  q: es verdadera si y s√≥lo si toda secuencia de transiciones posible alcanza un estado
que satisface q.
Donde q es un expresi√≥n l√≥gica bien formada, en ella podemos hacer referencia a variables
o estados de los procesos (instancias de esquemas), por ejemplo A[] MotherBoard.End imply MotherBoard.hasProcessor, especifica que para cualquier secuencia de ejecuci√≥n siempre es
cierto que si una instancia del esquema MotherBoard est√° en el estado End entonces su variable
hasProcessor debe ser verdadera.
4 De PPML a Uppaal
Con el objetivo de probar propiedades temporales de modelos especificados en PPML, se implement√≥ una traducci√≥n autom√°tica de modelos PPML al lenguaje Uppaal, as√≠ luego de traducir e
invocar al solver de Uppal podemos verificar dichas propiedades. La idea general de traducci√≥n
consiste en: Por cada clase de producto generar un esquema que describe sus estados dentro
del sistema. Por cada proceso se construye un esquema que describe su comportamiento. La
sem√°ntica de las puertas se incluyen dentro de los esquemas de productos y procesos. La comunicaci√≥n entre productos y procesos se realiza mediante variables compartidas (globales) y
7
mensajes de sincronizaci√≥n. Esta forma de traducir refleja la independencia de cada proceso y
nos permite incrementar la cantidad de instancias de productos dentro del sistema de manera
autom√°tica. Con el fin de ejemplificar la traducci√≥n se seguir√° el siguiente caso de estudio:
M
Pr
oc
M1
<M,Proc>
assem1
M
M2
M
em
<M,Mem>
assem2
M
D1
M
M
test1
test2
M
M
M3
M
Figura 6: Diagrama PPML assem1;assem2;[test1;test2](D1,M 3)
El proceso de ensamblado comienza con un proceso assem1 que recibe una MotherBoard
y un Procesador, los ensambla en un intervalo de entre 5 y 10 unidades de tiempo, seguidamente el proceso assem2 recibe el producto de salida del proceso anterior, una Memoria y los
ensambla con la misma restricci√≥n temporal. Luego se testean el Procesador y la Memoria de
la MotherBoard en paralelo por los procesos test1 y test2 respectivamente cuyos tiempos se
estiman entre 3 y 5 unidades.
4.1 Traducci√≥n de Procesos
Por cada proceso en PPML se genera:
‚Ä¢ En las declaraciones globales del sistema, canales de mensajes para la comunicaci√≥n con los
producto que procesa, esto es, un canal y una variable (del tipo de c√≥digo correspondiente)
por cada producto que el proceso manipula. Si bien en PPML, los procesos s√≥lo tienen un
producto de entrada, √©ste puede ser un producto compuesto (empaquetado), esto se refleja
en la traducci√≥n como la sincronizaci√≥n a trav√©s de los canales mencionados. Tambi√©n
se genera un canal (broadcast) por el cual, el proceso avisa a los productos intervinientes
que est√°n siendo procesados.
‚Ä¢ Un esquema con una declaraci√≥n de una variable reloj (tiempo que demora el proceso
en completarse), un estado inicial, los estados correspondientes a: la puerta previa ( en
caso de ser una puerta multimplexora, las posibles combinaciones de sincronizaciones de
los productos que el proceso manipula), un estado para representar la condici√≥n ‚Äúlisto
para comenzar‚Äù o pre-ejecuci√≥n del mismo y un estado para su pos-ejecuci√≥n. √âstos
dos √∫ltimos estados contienen como invariante, la traducci√≥n del Invariante del proceso
PPML. Las aristas que unen el estado inicial y los correspondientes a la sincronizaci√≥n de
productos, est√°n etiquetados con la espera por el correspondiente canal de comunicaci√≥n.
La arista que conecta los estados de pre y pos ejecuci√≥n del proceso tiene como guarda la
restricci√≥n temporal sobre la variable reloj del proceso. Finalmente un arco que reestablece
las condiciones para un pr√≥ximo proceso conectando el estado final con el inical.
‚Ä¢ Dentro de la declaraci√≥n del sistema, se generan una instacia por cada proceso.
8
Globales
//input sincronizations channels
urgent chan cassem2TMotherBoard;
urgent chan cassem2TMemory;
//procesing comunication channel
broadcast chan cAssem2;
//ids of the inputs products
n motherboards0 assem2 id motherboard;
n memories0 assem2 id memory;
Locales al esquema
clock x;
Sistema
Assem20 = Assem2();
Estados y Aristas del esquema
e1
l11
l12
l13
l14
e3
l2 e4
l3
e1: Estado Inicial (M2)
l11 : Sincr.: cassem2TMotherBoard?
l12 : Sincr.: cassem2TMemory?
l13 : Sincr.: cassem2TMotherBoard?
l14 : Sincr.: cassem2TMemory?
e2: Pre-assem2
l2: Guarda: x >=3 && x<=5
Sincr.: cassem2!
e3: Pos-assem2
l3: Modif.: x =0;
assem2 id memory = 0 ;
assem2 id motherboard = 0;
Figura 7: Traducci√≥n del Proceso assem2
4.2 Traducci√≥n de Productos
Por cada producto en PPML se genera:
‚Ä¢ Una definici√≥n de tipo subrango de entero 0..n en las declaraciones globales, que indica
n-1 instancias del producto. Estos valores ser√°n los c√≥digos o identificadores un√≠vocos de
cada producto dentro del sistema, el identificador 0 se reserva para el producto nulo, en
caso de productos estructurados incompletos.
‚Ä¢ Un esquema que contiene: Como declaraci√≥n local: una variable de tipo reloj (tiempo
del sistema). Una variable por cada atributo. En caso de ser estructurado, una variable
(identificador) por cada uno de sus componentes. Una funci√≥n por cada proceso que lo
manipula, en la cual se reflejan los cambios que realiza el proceso en los atributos del
producto. Un par√°metro constante del tipo correspondiente al los identificadores de
dicho producto, que es utilizado para la creaci√≥n de las instancias dentro del sistema.
Estados: un estado incial, un estado por cada proceso o puerta que lo manipula y
un estado final. Arcos: Para simplificar la traducci√≥n y sin p√©rdida de generalidad
asumimos que a cada proceso le precede una puerta (en caso de no existir asumimos
una puerta de tipo sem√°foro con la condici√≥n verdadero). De esta manera tenemos dos
tipos de arcos, los que van de un estado correspondiente a una puerta al de un proceso y
viceversa. Los primeros (epuerta,eproc.) est√°n etiquetados con un mensaje de escritura por
el canal correspondiente (listo para ser tratado) y la asignaci√≥n de su identificador en la
variable correspondiente al proceso en caso de que su valor sea 0 (no hay otro producto
esperando para ser tratado). Para los arcos (eproc. ,epuerta), un mensaje de espera por el
canal correspondiente al proceso, la condici√≥n de que el identificador del producto que el
proceso va a manipular sea el suyo y la invocaci√≥n a la funci√≥n que refleja los cambios
producidos por el proceso en sus atributos. En caso de productos que sean copiados por
demultiplexores, por ejemplo MotherBoard, estas bifurcaciones de procesamiento paralelo
se reflejar√°n en el esquema como todos los posibles casos (interleaving) en que el producto
puede ser procesado.
9
‚Ä¢ En la declaraci√≥n del sistema, se delaran las instancias de de los esquemas.
Globales
//amount of instances 2
typedef int[1,2] n_memories;
//amount of instances 2 + null
typedef int[0,2] n_memories0;
Locales al esquema
clock x;
//attributes
int size;
bool tested;
bool assembled;
//Processes Updates
void Assem2() assembled = true;
void Test2() tested = true;
Sistema
Memories(const n_memories id) =
Memory(id);
Estados y Aristas del esquema
e1
l1 e2
l2 e3
l3 e4
l4 e5
e1: Estado Inical (M2)
l1: Guarda: assem2 id memory = 0;
Sincr.: cassem2TMemory!
Modif.: assem2 id memory = id
e2: assem2
l2: Guarda: assem2 id memory == id
Sincr.: cassem2?
Modif.: Assem2()
e3: D1
l3: Guarda: test2 id memory = 0;
Sincr.: ctest2TMemory!
Modif.: test2 id memory = id
e4: test2
l4: Guarda: test2 id memory == id
Sincr.: ctest2?
Modif.: Test2()
e5: Estado Final (M3)
Figura 8: Traducci√≥n del Producto Memory
4.3 Declaraci√≥n del sistema y verificaci√≥n de propiedades
Finalmente se genera la declaraci√≥n del sistema con todas las instancias de los esquemas de procesos y productos. Con el modelo generado podemos invocar al verificador con las propiedades
que deseamos verificar.
Como parte del caso de estudio se verificaron las siguientes propiedades:
1) A[] forall (i:n_motherboards) forall (j:n_motherboards)
i != j imply ((MotherBoards(i).End and MotherBoards(j).End)
imply (MotherBoards(i).id_Memory != MotherBoards(j).id_Memory
and MotherBoards(i).id_Processor != MotherBoards(j).id_Processor))
Toda MotherBoard ensamblada no puede compartir su memoria ni su procesador con otra.
2) A[] forall(i:n_motherboards) (MotherBoards(i).End imply
(MotherBoards(i).id_Memory!=0 and MotherBoards(i).id_Processor!=0
and Processors(MotherBoards(i).id_Processor).tested == true and
Memories(MotherBoards(i).id_Memory).tested == true)
Toda MotherBoard que llege al final del proceso es ensamblada con una memoria y un procesador
testeados.
10
3) E<> exists(i:n_motherboards)(MotherBoards(i).End and
MotherBoards(i).x<=13)
Los testeos puden realizarse en paralelo reduciendo el tiempo de producci√≥n (13 es la suma de
los tiempos m√≠nimos de los procesos del modelo).
Las propiedades se verificaron en una PC con un procesador Intel Pentium 4 de 3 ghz y
2GByte memoria DDR con sistema operativo Linux, los detalles de los tiempos son:
2 c/prod. 3 c/prod. 3 Moth., 4 Proc. y Mem. 3 Moth., 5 Proc. y Mem.
1) 0,18 s 15,83 s 22,15 s > 3 h
2) 0,02 s 0,97 s 6,13 s > 3 h
3) 0,001 s 0,01 s 4,51 s 826,23 s
Nota: Los experiemtos se realizaron con la cantidad Procesadores y Memorias suficientes para
la cantidad de MotherBoards, es decir, almenos un Procesador y una Memoria por MotherBoard; caso contrario propiedades como 2 no pod√≠an verificarse, tal como se esperaba. Con
4 MotherBoards al igual que en los casos de 3 MotherBoards, 5 Procesadores y 5 Memorias,
pasadas las 3 horas de ejecutada la verificaci√≥n y habiendo duplicado el espacio de memoria
virtual con respecto al f√≠sico, se cancelaron las verificaciones.
5 Conclusiones y Trabajos Futuros
Hemos mostrado una traducci√≥n de modelos del lenguaje PPML al de Uppaal con el fin de
poder verificar propiedades temporales de los mismos. Actualemnte se esta desarrollando una
herramienta para asistir en la creaci√≥n de modelos en PPML y, como extensi√≥n de la misma,
la traducci√≥n autom√°tica propuesta. Creemos que el lenguaje PPML es de gran utilidad para
el modelado de diversos procesos en los cuales se necesite un an√°lisis formal. Por medio de
este trabajo se puede contar con una herramienta autom√°tica que facilita la construccion de
modelos de negocios y verificar en ellos propiedades de safety, invariancia, etc.
Debido al problema de la explosi√≥n de estados, se est√° estudiando la posibilidad de aplicar
t√©cnicas de abstracci√≥n [5] para poder explorar modelos con dominios de productos y procesos
m√°s grandes.
11
