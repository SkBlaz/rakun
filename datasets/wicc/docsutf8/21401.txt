B√∫squedas en bases de datos no convencionales
ÔªøB√∫squedas en Bases de Datos no Convencionales 
Diego Arroyuelo, Ver√≥nica Ludue√±a y Nora Reyes - darroy,vlud,nreyes@unsl.edu.ar
Dpto. de Inform√°tica - Universidad Nacional de San Luis - Tel.: 02652-420822-257 - Fax: 02652-430224
Gonzalo Navarro - gnavarro@dcc.uchile.cl
Dpto. de Ciencias de la Computaci√≥n - Universidad de Chile - Tel.: +56-2-6892736 - Fax: +56-2-6895531
1 Introducci√≥n y motivaci√≥n
Con la evoluci√≥n de las tecnolog√≠as de informaci√≥n y comunicaci√≥n, han surgido almacenamientos no estructurados de informaci√≥n. No s√≥lo se consultan nuevos tipos de datos tales como texto libre, im√°genes, audio y video;
sino que adem√°s, en algunos casos, ya no se puede estructurar m√°s la informaci√≥n en claves y registros. A√∫n cuando sea posible una estructuraci√≥n cl√°sica, nuevas aplicaciones tales como la miner√≠a de datos requieren acceder a
la base de datos por cualquier campo y no s√≥lo por aquellos marcados como ‚Äúclaves‚Äù.
Los escenarios anteriores requieren modelos m√°s generales tales como bases de datos de texto o espacios
m√©tricos, entre otros; y contar con herramientas que permitan realizar b√∫squedas eficientes sobre estos tipos de
datos. Las t√©cnicas que emergen desde estos campos muestran un √°rea de investigaci√≥n propicia para el desarrollo
de herramientas que resuelvan eficientemente los problemas involucrados en la administraci√≥n de bases de datos
no convencionales.
Como los problemas han aparecido en √°reas muy diversas, las soluciones tambi√©n han surgido desde muchos
campos no relacionados. Algunos ejemplos son bases de datos no convencionales (donde se buscan objetos similares); aprendizaje de m√°quina y clasificaci√≥n (donde se debe clasificar un nuevo elemento por su elemento m√°s
cercano existente); cuantizaci√≥n y compresi√≥n de im√°genes (donde s√≥lo algunos vectores pueden ser representados y, aqu√©llos que no, deben ser codificados como su punto representativo m√°s cercano); recuperaci√≥n de texto
(donde se buscan palabras permitiendo un peque√±o n√∫mero de errores, o se buscan documentos que sean similares
a un documento dado, o se buscan todas las apariciones de un determinado patr√≥n); etc.
La b√∫squeda por similitud es un tema de investigaci√≥n que abstrae varias nociones de las ya mencionadas.
Este problema se puede expresar como sigue: dado un conjunto de objetos de naturaleza desconocida, una funci√≥n
de distancia definida entre ellos, que mide cu√°n diferentes son, y dado otro objeto, llamado la consulta, encontrar
todos los elementos del conjunto suficientemente similares a la consulta. El conjunto de objetos junto con la
funci√≥n de distancia se denomina espacio m√©trico.
En algunas aplicaciones, los espacios m√©tricos resultan ser de un tipo particular llamado ‚Äúespacio vectorial‚Äù,
donde los elementos consisten de  coordenadas de valores reales. Existen muchos trabajos que explotan las
propiedades geom√©tricas sobre espacios vectoriales (ver [GG98] para m√°s detalles); pero normalmente √©stas no se
pueden extender a los espacios m√©tricos generales.
Se han logrado algunos avances importantes para espacios m√©tricos generales, en su gran mayor√≠a alrededor
de la idea de construir un √≠ndice que reduzca el n√∫mero de evaluaciones de distancia durante la consulta. En
muchas aplicaciones, aunque es muy importante reducir el n√∫mero de evaluaciones de la distancia, tambi√©n es
importante reducir la cantidad de operaciones de E/S realizadas. Algunos trabajos recientes persiguen este doble
objetivo (por ejemplo ver [CPZ97, Ver95]).
Por otra parte, una base de datos de texto es un sistema que debe proveer acceso eficiente a grandes vol√∫menes
de texto no estructurado, donde existe la necesidad de construir √≠ndices que no s√≥lo permitan realizar b√∫squedas
Este trabajo ha sido financiado parcialmente por el Proyecto RIBIDI CYTED VII.19 RIBIDI (todos los autores) y por el
Centro del N√∫cleo Milenio para Investigaci√≥n de la Web, Grant P01-029-F, Mideplan, Chile (√∫ltimo autor).
eficientes de patrones ingresados por el usuario, sino que adem√°s usen tan poco espacio como sea posible. En el
escenario m√°s simple, el texto se ve como una secuencia de s√≠mbolos y el patr√≥n a buscar como otra secuencia
m√°s breve, y as√≠ el problema de b√∫squeda consiste en encontrar todas las apariciones del patr√≥n en el texto.
La necesidad de una respuesta r√°pida y adecuada, y un eficiente uso de memoria, hace necesaria la existencia
de estructuras de datos especializadas que incluyan estos aspectos. En particular, nos vamos a dedicar a dos tipos
de bases de datos no convencionales: los Espacios M√©tricos y las Bases de Datos de Texto, y c√≥mo resolver
eficientemente las b√∫squedas en esos √°mbitos.
Existen indices que, en principio, resuelven ambos tipos de problemas; pero a√∫n est√°n muy inmaduros para
ser usados en la vida real por dos motivos importantes:
 falta de dinamismo,
 necesidad de trabajar en memoria principal.
Estas caracteristicas son sobreentendidas en bases de datos tradicionales, y la investigaci√≥n apunta a poner
estas nuevas bases de datos a un nivel de madurez similar.
2 Espacios M√©tricos
El planteo general del problema es: dado un conjunto    , recuperar los elementos de  que sean similares
a uno dado, donde la similitud entre elementos es modelada mediante una funci√≥n de distancia positiva . El
conjunto  denota el universo de objetos v√°lidos y  , un subconjunto finito de  , denota la base de datos en
donde buscamos. El par    es llamado espacio m√©trico. La funci√≥n        cumple con las
propiedades propias de una funci√≥n de distancia, positividad estricta, simetr√≠a y desigualdad tringular
B√°sicamente, existen dos tipos de b√∫squedas de inter√©s en espacios m√©tricos:
 B√∫squeda por rango: recuperar todos los elementos de  que est√°n a distancia  de un elemento  dado.
 B√∫squeda de los k vecinos m√°s cercanos: dado , recuperar los  elementos m√°s cercanos a .
En muchas aplicaciones, la evaluaci√≥n de la funci√≥n , suele ser una operaci√≥n costosa. Es por esta raz√≥n,
que en la mayor√≠a de los casos la cantidad de evaluaciones de distancias necesarias para resolver la b√∫squeda, se
usa como medida de complejidad . En otros casos, cuando el √≠ndice deber√° alojarse en memoria secundaria, es
necesario prestar atenci√≥n tambi√©n a los tiempos involucrados en la E/S.
Las investigaciones en la actualidad tienden al estudio de algoritmos en espacios m√©tricos generales, donde
existen varias t√©cnicas conocidas para resolver el problema en un n√∫mero sublineal de c√°lculos de distancia, con la
condici√≥n del preprocesamiento de  . En general las estructuras sobre las que trabajan dichos algoritmos suponen
que los espacios son est√°ticos.
Los algoritmos de b√∫squeda en espacios m√©tricos generales se dividen en dos grandes √°reas: algoritmos
basados en pivotes y algoritmos basados en particiones compactas (ver [CNBYM01] para un an√°lisis detallado).
Una de las estructuras que ha mostrado tener un buen comportamiento en espacios de alta dimensi√≥n o consultas de baja selectividad es el √Årbol de Aproximaci√≥n Espacial (SAT), ver [Nav02b]. El SAT es una estructura de
datos totalmente est√°tica y nuestro objetivo fue estudiarlo, a fin de lograr una estructura completamente din√°mica
que realice eficientemente las b√∫squedas.
2.1 √Årbol de Aproximaci√≥n Espacial
Para mostrar la idea general de la aproximaci√≥n espacial se utilizan las b√∫squedas del vecino m√°s cercano.
En este modelo, dado un punto  	  y estando posicionado en alg√∫n elemento  	  el objetivo es moverse
a otro elemento de  que est√© m√°s cerca ‚Äúespacialmente‚Äù de  que . Cuando no es posible realizar m√°s este
movimiento, se est√° posicionado en el elemento m√°s cercano a  de .
Estas aproximaciones son efectuadas s√≥lo v√≠a los ‚Äúvecinos‚Äù. Cada elemento  	  tiene un conjunto de
vecinos 	. La estructura natural para representar esto es un grafo dirigido. Los nodos son los elementos del
conjunto y los elementos vecinos son conectados por un arco. La b√∫squeda procede sobre tal grafo simplemente
posicion√°ndose sobre un nodo arbitrario  y considerando todos sus vecinos. Si ning√∫n nodo est√° m√°s cerca de
 que , entonces se responde a  como el vecino m√°s cercano a . En otro caso, se selecciona alg√∫n vecino 
 de
 que est√° m√°s cerca de  que  y se mueve a 
. Para obtener el SAT se simplifica la idea general comenzando la
b√∫squeda en un nodo fijo y realmente se obtiene un √°rbol.
El SAT est√° definido recursivamente; la propiedad que cumple la ra√≠z  (y a su vez cada uno de los siguientes
nodos) es que los hijos est√°n m√°s cerca de la ra√≠z que de cualquier otro punto de . La construcci√≥n del √°rbol se
hace de manera recursiva. De la definici√≥n se observa que se necesitan de antemano todos los elementos de la base
de datos para la construcci√≥n.
Luego de haber analizado distintas formas de realizar inserciones de elementos en el √°rbol, obtuvimos un
nuevo m√©todo que permite realizar la construcci√≥n incremental de SAT a un costo muy inferior a la versi√≥n est√°tica
y que mantiene el costo de las b√∫squedas en la mayor√≠a de los casos menor, y en otros levemente mayor que
la versi√≥n original. En [NR02, Rey02] se present√≥ una versi√≥n completamente din√°mica del SAT. El √Årbol de
Aproximaci√≥n Espacial Din√°mico (SATD) construye un √°rbol con aridad acotada y guarda en cada nodo un
timestamp que marca el tiempo en que se insert√≥ dicho elemento en el √°rbol.
Al incorporar un nuevo elemento , √©ste se inserta en el punto m√°s apropiado, si es que no se supera la cota
de la aridad; en otro caso se contin√∫a la b√∫squeda del lugar de inserci√≥n a partir del vecino m√°s cercano. Sea 

el punto resultante para la inserci√≥n, luego  se agrega como el vecino m√°s nuevo de 
 y no se efect√∫a ning√∫n
tipo de reconstrucci√≥n. Ahora claramente, no se fuerza a un elemento a aparecer en la vecindad del m√°s cercano.
En tiempo de b√∫squeda alcanzaremos al elemento insertado porque los procesos de inserci√≥n y b√∫squeda son
similares. Las b√∫squedas se pueden optimizar haciendo uso del timestamp.
Las eliminaciones son mucho m√°s complicadas porque los cambios a realizar en la estructura son m√°s costosos, y no son localizados, sino que se pueden propagar al resto de la estructura.
Los SATD son estructuras de datos adecuadas para b√∫squedas en espacios m√©tricos de alta dimensionalidad o
radios de b√∫squeda grandes, tienen tambi√©n un desempe√±o razonable para b√∫squedas en espacios de baja dimensionalidad (si la aridad del √°rbol es sintonizada correctamente). Sin embargo, dado un conjunto de  elementos,
utilizan un espacio fijo de almacenamiento, y aunque se disponga de m√°s espacio disponible no son capaces de
aprovecharlo para beneficio de las b√∫squedas.
Por otro lado, las estructuras basadas en pivotes se caracterizan principalmente por poder adaptarse al espacio
de almacenamiento disponible y lograr mejorar su comportamiento durante las b√∫squedas. En otras palabras, si
hay m√°s espacio disponible se utilizan m√°s pivotes por cada elemento de la base de datos, y se mejora el costo de
b√∫squeda.
Buscando lo mejor de ambos m√©todos, hemos dise√±ado el √Årbol de Aproximaci√≥n Espacial Din√°mico con
pivotes agregados (SATDP), que es una estructura de datos h√≠brida, basada en los conceptos de aproximaci√≥n
espacial y algoritmos de pivotes. La idea general es permitir que el SATDP pueda hacer buen uso del espacio
disponible almacenando pivotes en cada nodo y lograr una mejora en el costo de b√∫squeda.
De esta manera, al momento de inserci√≥n de un elemento  en el √°rbol se calculan las distancias entre  y sus
pivotes, almacenando esas distancias en el nodo de . Esto es para que esa informaci√≥n pueda ser usada durante
las b√∫squedas. Hasta el momento hemos trabajado con dos formas de elegir los pivotes de cada nodo:
 Usar los ancestros de cada nodo como pivotes del mismo.
 Usar los ancestros de cada nodo, m√°s los hermanos mayores de los ancestros como pivotes de cada nodo.
De esta manera el costo de inserci√≥n de cada elemento en el SATDP es el mismo que para el SATD original; simplemente almacenamos en cada nodo algunas de las distancias computadas durante la inserci√≥n de cada
elemento. Durante las b√∫squedas se usan estas distancias almacenadas en cada nodo del √°rbol para disminuir la
cantidad de evaluaciones de distancia. La idea es proceder con los criterios de aproximaci√≥n espacial s√≥lo con
aquellos nodos del √°rbol que no puedan ser descartados usando los pivotes. El descarte por pivotes se produce
sin evaluaciones de distancia adicionales, lo que ayuda disminuir la cantidad total de evaluaciones de distancia
realizadas durante las b√∫squedas.
3 Bases de Datos de Texto
Una base de datos de texto es un sistema que provee acceso eficiente a amplias masas de datos textuales. El
requerimiento m√°s importante es que desarrolle b√∫squedas r√°pidas para patrones ingresados por el ususario. El
escenario m√°s simple es como sigue: el texto 

se ve como una √∫nica secuencia de caracteres sobre un alfabeto
 de tama√±o , y el patr√≥n de b√∫squeda 

como otra (breve) secuencia sobre . Luego el problema de
b√∫squeda de texto consiste en encontrar todas las  ocurrencias de  en 
 .
Las bases de datos de texto modernas tienen que enfrentar dos objetivos opuestos. Por un lado, tienen que
proveer acceso r√°pido al texto y por el otro, tienen que usar tan poco espacio como sea posible. Los objetivos
son opuestos debido a que para proveer acceso r√°pido se debe construir un √≠ndice sobre el texto. Un √≠ndice es una
estructura de datos construida sobre el texto y almacenada en la base de datos y as√≠ incrementa los requerimientos
de espacio. Recientemente se ha investigado mucho sobre bases de datos de texto comprimido, enfoc√°ndose en
comprimirlo y, de ser posible, hacerlo de tal forma que las estructuras que representan al texto comprimido nos
sirvan tambi√©n para buscar en √©l. Un ejemplo de este tipo de √≠ndice es el LZ-Index.
3.1 LZ-Index
Para describir el LZ-Index, y como est√° basado en el Ziv-Lempel Trie, daremos una breve rese√±a del mismo. La idea
de la compresi√≥n Ziv-Lempel se basa en reemplazar substrings en el texto por punteros a apariciones anteriores de
los mismos. Si el puntero ocupa menos espacio que el substring que √©l reemplaza, entonces se logr√≥ compresi√≥n.
Existen distintas variantes de este tipo de compresi√≥n, aqu√≠ se ver√° s√≥lo el LZ78.
El LZ78 (algoritmo de compresi√≥n Ziv-Lempel de 1978) se basa en un diccionario de bloques. Supongamos
que tenemos el texto 
 de longitud  para comprimir, al principio del proceso el diccionario posee un √∫nico
bloque 


de longitud 0. Luego, suponiendo que ya se comprimi√≥ el prefijo 

de 
 en una secuencia de
bloques   


     


, todos ellos en el diccionario; el paso que sigue es buscar el prefijo m√°s largo del
texto 

que es un bloque del diccionario. Una vez encontrado este bloque, llam√©moslo 


de longitud 

,
construimos el nuevo bloque 


  



, y escribimos el par al final del archivo comprimido ; es decir,
  


     





, y agregamos el bloque al diccionario. Se agregar√° el car√°cter $ al final del texto, sabiendo
que es distinto que cualquier otro car√°cter, para asegurarnos que cada bloque corresponde a un bloque diferente.
Se ve que este diccionario es cerrado bajo prefijo (es decir que cualquier prefijo de un elemento es tambi√©n un
elemento del diccionario) y se puede representar naturalmente por un trie.
Una propiedad interesante de esta forma de compresi√≥n es que cada bloque representa un substring diferente
del texto, la √∫nica excepci√≥n puede ser el √∫ltimo bloque; pero eso se salva con el car√°cter que agregamos al final
($). Esta propiedad es aprovechada por este algoritmo, al igual que la posibilidad de ordenar lexicogr√°ficamente
el conjunto de strings almacenados.
Al finalizar el proceso hemos comprimido nuestro texto 

en    bloques 
  


   


, con 


 ,




 

	
si  
  (no hay dos bloques iguales), y   , 
   ,  	 , 

	
 


  (todos los bloques, salvo
el 


, se forman con un bloque anterior mas una letra); ahora debemos poder devolver todas las ocurrencias en el
mismo de un determinado patr√≥n 

.
Para buscar un patr√≥n en el texto debemos distinguir tres tipos de ocurrencias de  en 
 dependiendo de su
distribuci√≥n sobre los bloques:
 La ocurrencia cae dentro de un √∫nico bloque.
 La ocurrencia cruza dos bloques, 

	
y 

	
, tal que el prefijo 


coincide con un sufijo de 

	
y el sufijo



coincide con un prefijo de 

	
.
 La ocurrencia cruza tres o m√°s bloques, 

	
   


, tal que 


 

	
   


, 


coincide con un
sufijo de 

	
y el sufijo 

coincide con un prefijo de 


.
Para realizar la b√∫squeda junto con el LZtrie guardamos un RevLZTrie, formado por todos los strings 


   


invertidos. Estas dos estructuras nos permitir√°n realizar b√∫squedas eficientes.
El algoritmo que realiza este tipo de compresi√≥n y b√∫squeda aparece en [Nav02a], donde aparecen detalles
de implementaci√≥n de todas las estructuras necesarias, de forma tal que el espacio utilizado sea peque√±o y las
b√∫squedas se resuelvan de manera eficiente.
4 Trabajo Futuro
 SATD se prev√© analizar su comportamiento frente a otro tipo de operaciones no consideradas a√∫n y existentes en Bases de Datos Espaciales. Tambi√©n se estudiar√° c√≥mo modificarlo, a fin de obtener una buena
estructura para memoria secundaria. Claramente en este aspecto puede ayudar el definir la aridad m√°xima,
de manera tal de asegurar que entra todo en una p√°gina en memoria secundaria.
 SATDP se pretenden analizar otras t√©cnicas de selecci√≥n de pivotes que obtengan la mejor estructura para
b√∫squeda cuando se cuenta con memoria acotada. Adem√°s, se prev√© analizar m√°s detalladamente las operaciones de inserci√≥n y eliminaci√≥n para lograr mejorarlas haciendo uso de la informaci√≥n que brindan los
pivotes.
 LZ-Index el primer paso seria reemplazar el trie que se usa para construir RevTrie por uno que use caminos
comprimidos, exactamente como la versi√≥n comprimida. En una segunda etapa se va a tratar de construir
tanto el LZTrie como el RevTrie ya en forma comprimida, en vez de pasar por una versi√≥n descomprimida.
Adem√°s se pretende agregar dinamismo a las estructuras de modo de poder seguir agregando texto al ya
existente sin tener que reconstruir todo. Con la idea de permitir usar estas t√©cnicas en bases de datos
de texto que no puedan mantenerse en memoria principal, se tiene tambi√©n como objetivo obtener una
implementaci√≥n eficiente del √≠ndice en memoria secundaria.
